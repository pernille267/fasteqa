# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Resample Clustered Data
#' @name resample_samples
#'
#' @param data A \code{list} or a \code{data.table}. Must contain \code{SampleID},
#'        \code{ReplicateID}, \code{MP_A} and \code{MP_B}. The ID variables \code{SampleID}
#'        and \code{ReplicateID} must be of character type for the function to operate correctly.
#'
#' @details
#' This function is a very efficient method to resample clinical sample data on sample-level.
#' It is convenient to combine this function with \code{fasteqa} functions such as
#' \itemize{
#'   \item \code{global_precision_estimates()} to estimate bootstrap imprecision confidence intervals
#'   \item \code{estimate_zeta()} to estimate bootstrap zeta confidence intervals
#' }
#'
#' @return
#' A \code{list} containing the resampled data.
#'
#' @examples
#' print(1)
NULL

#' @title Resample Cluster Statistics Based on External Quality Assessment (EQA) Clinical Sample Data
#' @name resample_fun_of_samples
#'
#' @param data A \code{list} or \code{data.table}. The mean of replicates (MOR)
#'        clinical sample data. Must contain:
#'        \itemize{
#'           \item \code{SampleID}: A \code{character} vector of sample identifiers.
#'           \item \code{MP_A}: A \code{numeric} vector of measurements from method A (response).
#'           \item \code{MP_B}: A \code{numeric} vector of measurements from method B (predictor).
#'        }
#'
#' @description
#' This function resamples resamples sample statistics based on EQA clinical sample data
#' with replacement. This function can for example be used to create bootstrap-based estimations
#' of predictions and conclusion strengths.
#' 
#' @details
#' This function is an optimized method to resample clinical sample statistics
#' based on clinical sample data.
#' 
#' Note, if \code{ReplicateID} is part of \code{data}, this method may yield
#' unexpected results. For methods that require resampling of all replicated
#' measurements, please use \code{resample_samples()} instead.
#' 
#' Note also that the \code{SampleID} of the returned object does not correspond
#' with the actual values in the input \code{SampleID}. Thus, this function
#' should not be used to do inference on individual clinical samples!
#'
#' @return
#' A \code{list} that contains the resampled \code{data}.
#'
#' @examples
#' library(fasteqa)
#' mor_test_data <- fun_of_replicates(test_data)
#' mor_test_data$MP_A <- round(mor_test_data$MP_A, 2)
#' mor_test_data$MP_B <- round(mor_test_data$MP_B, 2)
#' resampled_data <- resample_fun_of_samples(mor_test_data)
#' print(as.data.frame(resampled_data))
NULL

#' @title Resample imprecision estimates based on clustered EQA clinical sample data 
#' @name resample_global_precision_estimates
#' 
#' @param data A \code{list} or \code{data.table}. Must contain
#'        \code{SampleID}, \code{ReplicateID}, \code{MP_A} and \code{MP_B}.
#'
#' @description
#' Resample \code{Var_B}, \code{Var_A}, \code{CV_B}, \code{CV_A} and \code{lambda} one time.
#'
#' @details
#' Uses \code{resample_samples()} to resample \code{data} on sample-level.
#' Then \code{global_imprecision_estimates()} is used to calculate the estimated values
#' of \code{Var_B}, \code{Var_A}, \code{CV_B}, \code{CV_A} and \code{lambda},
#' based on the resampled \code{data}. 
#'
#' @return
#' A \code{list} contaning the resampled imprecision estimates:
#' \itemize{
#'   \item \code{Var_A:} Pooled variance of all sample-variances based on \code{MP_A}
#'   \item \code{Var_B:} Pooled variance of all sample-variances based on \code{MP_B}
#'   \item \code{CV_A:} CV estimate based on Var_A and the grand mean of all measurements from \code{MP_A}
#'   \item \code{CV_B:} CV estimate based on Var_B and the grand mean of all measurements from \code{MP_B}
#'   \item \code{lambda:} Ratio of pooled variances \code{Var_A} and \code{Var_B}
#' }
#'
#' @examples 
#' library(fasteqa)
#' 
#' # Resample global imprecision estimates 3 times
#' rie <- replicate(n = 3,
#'                  expr = resample_global_precision_estimates(test_data),
#'                  simplify = FALSE)
#' rie <- lapply(X = rie,
#'               FUN = as.data.frame)
#' resampled_impr_estimates <- rbind(rie[[1]],
#'                                   rie[[2]],
#'                                   rie[[3]])
#' print(resampled_impr_estimates)
#' 
NULL

#' @title Resample \eqn{\hat{\zeta}} values based on clustered EQA clinical sample data 
#' @name resample_zeta_estimates
#' 
#' @param data A \code{list} or \code{data.table}. Must contain
#'        \code{SampleID}, \code{ReplicateID}, \code{MP_A} and \code{MP_B}.
#'
#' @description
#' Resample \code{zeta} one time.
#'
#' @details
#' Uses \code{resample_samples()} to resample \code{data} on sample-level.
#' Then \code{estimate_zeta()} is used to calculate \eqn{\hat{\zeta}},
#' based on the resampled \code{data}. 
#'
#' @return
#' A \code{list} contaning the resampled \eqn{\hat{\zeta}}.
#'
#' @examples
#' # Resample global imprecision estimates 1000 times
#' rze <- replicate(n = 1000,
#'                  expr = resample_zeta_estimates(test_data)$zeta,
#'                  simplify = TRUE)
#' # Get summary statistics of resampled zeta estimates
#' summary(rze)
#' 
NULL

#' @title Leave-one-out on clustered EQA clinical sample data
#' @name leave_one_out
#' 
#' @param data A \code{list} or \code{data.table}. Must contain
#'        \code{SampleID}, \code{ReplicateID}, \code{MP_A} and \code{MP_B}.
#' @param loo_id An \code{integer}. The \code{SampleID} that is left out.
#'        Default value is \code{1}.
#'
#' @description Needed to calculate jack knife estimates of a parameter, that is required when using \code{BCa_bootstrap_ci()}. Alternatively one could use the Jack knife estimates to calculate standard error or bias of the estimator of relevance
#'
#' @details loo_ids can not be vectorized directly in R. Use \code{sapply()} or \code{replicate()} to leave out sample IDs one by one 
#'
#' @return A \code{list} containing the original data, but without the sample id corresponding to the given \code{loo_id} 
#'
#' @examples
#' # Get data without the fifth sample
#' print(as.data.frame(leave_one_out(test_data, 5L)))
#' 
NULL

#' @title Leave-One-Out (LOO) Imprecision Estimates Based on Clustered EQA Clinical Sample Data 
#' @name loo_global_precision_estimates
#' 
#' @param data A \code{list} or \code{data.table}. Must contain
#'        \code{SampleID}, \code{ReplicateID}, \code{MP_A} and \code{MP_B}.
#' @param loo_id A \code{integer}. The ID of the \code{SampleID} to be
#'        excluded before calculating the imprecision estimates.
#'
#' @description
#' Calculate \code{Var_B}, \code{Var_A}, \code{CV_B}, \code{CV_A} and \code{lambda} without
#' the \code{loo_id}-th SampleID.
#'
#' @details
#' Uses \code{leave_one_out()} to remove one unique value of \code{SampleID} from \code{data}
#' Then \code{global_imprecision_estimates()} is used to calculate the estimated values
#' of \code{Var_B}, \code{Var_A}, \code{CV_B}, \code{CV_A} and \code{lambda},
#' based on the \code{data} without the data from the \code{loo_id}-th \code{SampleID} value. 
#'
#' @return
#' A \code{list} contaning the LOO imprecision estimates:
#' \itemize{
#'   \item \code{Var_A:} Pooled variance of all sample-variances based on \code{MP_A}
#'   \item \code{Var_B:} Pooled variance of all sample-variances based on \code{MP_B}
#'   \item \code{CV_A:} CV estimate based on Var_A and the grand mean of all measurements from \code{MP_A}
#'   \item \code{CV_B:} CV estimate based on Var_B and the grand mean of all measurements from \code{MP_B}
#'   \item \code{lambda:} Ratio of pooled variances \code{Var_A} and \code{Var_B}
#' }
#'
#' @examples
#' library(fasteqa)
#' # Estimate imprecision estimates without the second clinical sample
#' gpe <- loo_global_precision_estimates(test_data, 2L)
#' 
#' # Output
#' print(as.data.frame(gpe))
#'
NULL

#' @title Calculate the \eqn{\hat{\zeta}} Value When One Observation is Removed
#' @name loo_zeta_estimates
#' 
#' @param data A \code{list} or \code{data.table}. Must contain
#'        \code{SampleID}, \code{ReplicateID}, \code{MP_A} and \code{MP_B}.
#'
#' @description
#' Resample \code{zeta} one time.
#'
#' @details
#' One unique value of \code{SampleID} is removed from \code{data}.
#' Then \code{estimate_zeta()} is used to calculate \eqn{\hat{\zeta}},
#' based on \code{data} without the data from the \code{loo_id}-th \code{SampleID} value.
#'
#' @return
#' A \code{list} contaning the resampled \eqn{\hat{\zeta}}.
#'
#' @examples \dontrun{
#'   # Estimate zeta without the second clinical sample
#'   print(loo_zeta_estimatees(test_data, 2L)$zeta)
#' }
NULL

#' @title Simple Bootstrap Confidence Interval Estimation
#' @name bootstrap_ci
#' 
#' @param bootstrapped_parameter_estimates A \code{numeric} vector containing 
#'        resampled parameter estimates. Missing values (\code{NA}) are automatically 
#'        removed without a warning. Must contain at least \eqn{2} valid observations.
#' @param jackknife_parameter_estimates A \code{numeric} vector containing Jackknife
#'        estimates of the target parameter.
#'        Missing values (\code{NA}) will be removed automatically.
#' @param original_parameter_estimate A \code{double} representing the parameter 
#'        estimate from the original sample. Must be a single non-missing value.
#' @param type An `integer` specifying the confidence interval method:
#' \itemize{
#'   \item \code{1} - Standard normal bootstrap confidence interval
#'   \item \code{2} - Basic bootstrap confidence interval
#'   \item \code{3} - Percentile bootstrap confidence interval
#'   \item \code{4} - Bias and skewness corrected bootstrap confidence interval
#' }
#' @param level A \code{double} between 0.50 and 0.99 indicating the confidence level. 
#'        Default: 0.95 (95\% interval)
#' @param silence An \code{integer} controlling verbosity:
#' \itemize{
#'   \item \code{-1} - Detailed debug output
#'   \item \code{0} - Basic progress reporting
#'   \item \code{1} - No output (default)
#' }
#'
#' @description
#' Calculates nonparametric bootstrap confidence intervals using four common methods.
#' Suitable for situations where only bootstrap replicates and the original estimate 
#' are available.
#'
#' @details
#' Methodological Notes
#' \itemize{
#'   \item Standard Normal (Type 1): Assumes normal distribution of bootstrap estimates
#'   \item Basic (Type 2): Computes interval using bootstrap distribution's quantiles
#'   \item Percentile (Type 3): Directly uses empirical quantiles of bootstrap estimates
#'   \item BCa (Type 4): Uses bias- and skewness corrected bootstrap quantiles
#' }
#' 
#' The function automatically removes \code{NA} values from bootstrap estimates without a warning.
#' For reliable results, use \eqn{\geq 1000} bootstrap replicates.
#' BCa intervals require jackknife estimates. 
#'
#' @return A \code{numeric} vector \code{x} of length 2 containing:
#' \itemize{
#'   \item \code{x[1]} - Lower confidence bound
#'   \item \code{x[2]} - Upper confidence bound
#' }
#'
#' @examples
#' # Simulated dataset
#' true_mean <- 5.2
#' bootstrap_means <- rnorm(1000, mean = 5.0, sd = 0.5)
#' jackknife_means <- rnorm(25, mean = 5.1, sd = 0.75)
#' 
#' # Calculate 90% percentile interval
#' bootstrap_ci(
#'   bootstrapped_parameter_estimates = bootstrap_means,
#'   jackknife_parameter_estimates = bootstrap_means,
#'   original_parameter_estimate = true_mean,
#'   type = 3,
#'   level = 0.90
#' )
#' 
#' # Calculate 95% BCa interval
#' bootstrap_ci(
#'   bootstrapped_parameter_estimates = bootstrap_means,
#'   jackknife_parameter_estimates = jackknife_means,
#'   original_parameter_estimate = true_mean,
#'   type = 4,
#'   level = 0.95
#' )
#'
#' @references
#' Bootstrap methods and their application (Davison & Hinkley, 1997)
NULL

resample_samples <- function(data) {
    .Call(`_fasteqa_resample_samples`, data)
}

resample_fun_of_samples <- function(data) {
    .Call(`_fasteqa_resample_fun_of_samples`, data)
}

resample_global_precision_estimates <- function(data) {
    .Call(`_fasteqa_resample_global_precision_estimates`, data)
}

resample_zeta_estimates <- function(data) {
    .Call(`_fasteqa_resample_zeta_estimates`, data)
}

leave_one_out <- function(data, loo_id = 1L) {
    .Call(`_fasteqa_leave_one_out`, data, loo_id)
}

loo_global_precision_estimates <- function(data, loo_id = 1L) {
    .Call(`_fasteqa_loo_global_precision_estimates`, data, loo_id)
}

loo_zeta_estimates <- function(data, loo_id = 1L) {
    .Call(`_fasteqa_loo_zeta_estimates`, data, loo_id)
}

bootstrap_ci <- function(bootstrapped_parameter_estimates, jackknife_parameter_estimates, original_parameter_estimate = 0, type = 3L, level = 0.95, silence = 1L) {
    .Call(`_fasteqa_bootstrap_ci`, bootstrapped_parameter_estimates, jackknife_parameter_estimates, original_parameter_estimate, type, level, silence)
}

#' @title Count the Number of Replicated for Each Sample
#' @name count_samplewise_replicates
#'
#' @param data A \code{list} or \code{data.table} representing CS data or EQAM data
#'        with the \code{list} elements or \code{data.table} columns:
#'        \code{SampleID}, \code{MP_A}, and \code{MP_B}.
#' @param summary A \code{character} specifying the summary statistic of the sample-wise
#'        numbers of replicates. Default is \code{'mode'}. Possible summary statistics include:
#'        \itemize{
#'           \item \code{none}: Returns an \code{integer} vector containing every
#'           sample-wise number of replicatees for \code{data}.
#'           \item \code{mode}: Returns the sample mode.
#'           \item \code{median}: Returns the sample median.
#'           \item \code{mean}: Returns the sample mean.
#'           \item \code{ceiling}: Returns the rounded up (to nearest integer) sample mean.
#'           \item \code{floor}: Returns the rounded down (to nearest integer) sample mean.
#'           \item \code{round}: Returns the rounded (to nearest integer) sample mean.
#'        }
#' @param invalid_NA A \code{logical} that determines the behavior of the function in response
#'        to invalid \code{data} or \code{summary} input.
#'        If \code{TRUE}, the function will return an \code{NA}-value when encountering
#'        invalid input or computation errors, rather than throwing an error.
#'        While generally not recommended due to potential masking of issues,
#'        this may be useful in certain scenarios where uninterrupted execution is desired.
#' @param silence An \code{integer} that dictates the verbosity level of the console output.
#'        If \code{silence} is set to a value less than 1, various verbose output,
#'        including debugging reports, will be displayed depending on the specific
#'        value of \code{silence}.
#' 
#' @description
#' This function counts the number of replicated measurements done on each sample
#' within an IVD-MD comparison for either clinical sample (CS) data or
#' external quality asessment material (EQAM) data. Alternatively, a summary
#' statistic can be returned to summarize the numbers of replicates across all
#' samples in the \code{data}.
#'
#' @details
#' The function \code{predict_eqa()} hinges on the count of replicates
#' performed for its \code{data} parameter. When the \code{method} is either
#' \code{fg} or \code{ols}, it is essential to tally the replicates for both
#' \code{data} and \code{new_data} inputs. This handy function offers a
#' streamlined solution. It allows for the direct usage of \code{predict_eqa()}
#' without requiring manual counting of the sample-wise replicates,
#' thereby enhancing efficiency and ease of use.
#' 
#' Note: If the count of replicates for a particular sample is 0, it will be
#' removed from the output. 
#'
#' @return
#' Returns a \code{list} that contains a single element, \code{R_i}.
#' The type of \code{R_i} depends on the \code{summary} parameter.
#' It is typically an single integer value.
#' However, if \code{summary} is set to \code{'none'}, \code{R_i} is an
#' integer vector because it list the number of replicates for each sample.
#' When \code{summary} is set to \code{'mean'},
#' \code{R_i} is returned as a \code{double}.
#'
#' @examples \dontrun{
#' library(fasteqa)
#' # Simulation parameters for clinical sample data
#' cs_parameters <- list(n = 25, R = 3,
#'                       cvx = 0.01, cvy = 0.015,
#'                       cil = 10, ciu = 70)
#' # Use the simulation parameters to simulate toy clinical sample data                      
#' cs_data <- simulate_eqa_data(cs_parameters)
#' # Calculate mode of sample-wise number of replicates
#' mode_R <- count_samplewise_replicates(cs_data, summary = 'mode')$R_i
#' # Count sample-wise number of replicates
#' samplewise_R <- count_samplewise_replicates(cs_data, summary = 'none')$R_i                                    
#' }
NULL

count_samplewise_replicates <- function(data, summary = "mode", invalid_NA = TRUE, silence = 1L) {
    .Call(`_fasteqa_count_samplewise_replicates`, data, summary, invalid_NA, silence)
}

#' @title Calculate Sample Skewness of a Random Sample
#' @name skewness
#'
#' @param x A \code{numeric} vector. A random sample.
#' @param na_rm A \code{logical} value. If \code{TRUE}, \code{NA}-values are
#'        removed prior to calculation of the sample skewness.
#'
#' @description
#' Calculates the sample skewness of a random sample \code{x}, using the
#' adjusted Fisher-Pearson standardized moment coefficient.
#' 
#' @details
#' Calculates the sample skewness of a random sample
#' \eqn{\lbrace x_i \rbrace_{i=1}^{N}}. The sample skewness, attempts to
#' estimate the theoretical skewness, \eqn{\gamma}, by using
#' the following estimator (adjusted Fisher-Pearson standardized moment
#' coefficient):
#'
#' \eqn{\hat{\gamma} = \frac{\sqrt{N(N-1)}}{N-2} \cdot
#' \frac{\frac{1}{N}\sum_{i=1}^{N}(x_i - \overline{x})^3}
#' {\Big[\frac{1}{N}\sum_{i=1}^{N}(x_i - \overline{x})^2\Big]^{1.5}}}.
#'
#' Note: This estimator biased if not \eqn{x_i \sim \mathrm{N}(\mu, \sigma^2)}.
#'
#' @return A \code{double}. The calculated sample skewness.
#'
#' @examples
#' 
#' # Reproducibility
#' set.seed(99)
#' 
#' # Simulate 1 million observations from log-normal(0, 0.25)
#' y <- rlnorm(n = 1e6, meanlog = 0, sdlog = 0.25)
#' sample_skew <- skewness(y)
#' 
#' # Theoretical skew for log-normal(0, 0.25)
#' theoretical_skew <- (exp(0.25^2) + 2) * sqrt(exp(0.25^2) - 1)
#' 
#' cat("Theoretical skewness:", round(theoretical_skew), "\n",
#'     " Empirical skewness:", round(sample_skew), "\n")
#' 
#' 
NULL

#' @title Calculate Sample Excess Kurtosis of a Random Sample
#' @name kurtosis
#'
#' @param x A \code{numeric} vector. A random sample.
#' @param na_rm A \code{logical} value. If \code{TRUE}, \code{NA}-values are
#'        removed prior to calculation of the sample excess kurtosis.
#'        
#' @description
#' Calculates the sample excess kurtosis of a random sample \code{x}, using
#' the adjusted Fisher-Pearson standardized moment coefficient estimator.
#' 
#' @details
#' Calculates the sample excess kurtosis of a random sample
#' \eqn{\lbrace x_i \rbrace_{i=1}^{N}}. The sample excess kurtosis, attempts
#' to estimate the theoretical excess kurtosis, \eqn{\Kappa}, by using
#' the following estimator (adjusted Fisher-Pearson standardized moment
#' coefficient):
#'
#' \eqn{\hat{\Kappa} = \frac{N(N+1)}{(N-1)(N-2)(N-3)} \cdot \frac{\sum_{i=1}^{N}(x_i - \overline{x})^4}{s^4} - 3 \cdot \frac{(N-1)^2}{(N-2)(N-3)}}.
#'
#' Here, \eqn{s^2} is the unbiased sample variance.
#' 
#' 
#' Note: this estimator will be biased if not
#' \eqn{x_i \sim \mathrm{N}(\mu, \sigma^2)}. Moreover, \eqn{\hat{\Kappa}}
#' estimates the theoretical excess kurtosis and not the raw kurtosis. Add
#' \eqn{3} to the sample excess kurtosis to get the sample raw kurtosis.
#'
#' @return A \code{double}. The calculated sample excess kurtosis.
#'
#' @examples
#' # Reproducibility
#' set.seed(99)
#' 
#' # Simulate from one million observations from N(0, 1)
#' y <- rnorm(n = 1e6)
#' sample_excess_kurt <- kurtosis(y)
#' 
#' # Compare with theoretical excess kurtosis of N(0, 1)
#' cat("Theoretical excess kurtosis:", round(0, 3), "\n",
#'     " Empirical excess kurtosis:", round(sample_excess_kurt, 3), "\n")
#' 
NULL

skewness <- function(x, na_rm = TRUE) {
    .Call(`_fasteqa_skewness`, x, na_rm)
}

kurtosis <- function(x, na_rm = TRUE) {
    .Call(`_fasteqa_kurtosis`, x, na_rm)
}

#' @title Fit a Ordinary Least Squares Model
#' @name ols_regression
#'
#' @param data A \code{list} or \code{data.table}. Must contain:
#'             \itemize{
#'                 \item \code{MP_A: } A \code{numeric} vector. The means of
#'                 replicated measurements from IVD-MD \code{MP_A} (response).
#'                 \item \code{MP_B: } A \code{numeric} vector. The means of
#'                 replicated measurements from IVD-MD \code{MP_B} (predictor).
#'             }
#'        
#' @description
#' Fits a Ordinary Least Squares (OLS) regression model to \code{data}. 
#' 
#' @details
#' No details are needed. It is OLS.
#'
#' @return A \code{list}. Contains information on the fitted model.
#'
#' @examples
#' # Reproducibility
#' set.seed(99)
#' 
#' print(rbinom(1, 5, 0.5))
#' 
ols_regression <- function(data) {
    .Call(`_fasteqa_ols_regression`, data)
}

#' @title Perform a Breusch-Pagan Test
#' @name pb_test
#'
#' @param data A \code{list} or \code{data.table}. Must contain:
#'             \itemize{
#'                 \item \code{MP_A: } A \code{numeric} vector. The means of
#'                 replicated measurements from IVD-MD \code{MP_A} (response).
#'                 \item \code{MP_B: } A \code{numeric} vector. The means of
#'                 replicated measurements from IVD-MD \code{MP_B} (predictor).
#'             }
#' @param koenker A \code{logical} value. If \code{TRUE} (default), the Koenker
#'                modification is applied to the make the test more robust
#'                when data is non-normal.
#'        
#' @description
#' Performs a Breusch Pagan test on variance heterogeneity on \code{data}. 
#' 
#' @details
#' The Breusch-Pagan test and its Koenker modification are both used to detect
#' heteroskedasticity in linear regression models.
#' 
#' The Koenker version, proposed by Koenker in 1981, modifies the test to make
#' it more robust when the data is non-normal. Note however, that the Koenker
#' version will have poorer power than the unmodified Breusch-Pagan test if
#' the data is close to normal.
#' 
#' Note: \code{NA}-values are silently removed prior to calculating the 
#' Breusch-Pagan test statistic.
#'
#' @return A \code{double}. The calculated p-value of the test.
#'
#' @examples
#' 
#' # Required packages
#' library(fasteqa)
#' 
#' # Reproducibility
#' set.seed(99)
#' 
#' # Simulate some example data
#' x <- runif(n = 50, min = 0, max = 1)
#' y <- 0.1 + 0.9 * x + rnorm(n = 50, mean = 0, sd = 0.05 * (x + 1))
#' data <- list(MP_A = y,
#'              MP_B = x)
#' 
#' # The output (rounded to 3L)
#' print(round(bp_test(data), 3L))
#' 
#' 
bp_test <- function(data, koenker = TRUE) {
    .Call(`_fasteqa_bp_test`, data, koenker)
}

#' @title Quantify Differences in Non-selectivity Using \eqn{\hat{\zeta}}
#' @name estimate_zeta_ols
#' @param data A \code{list} or \code{data.table}. Must contain:
#'             \itemize{
#'               \item \code{SampleID: } A \code{character} vector. The
#'                     clinical sample identifiers.
#'               \item \code{ReplicateID: } A \code{character} vector. The
#'                     replicate measurement identifiers.
#'               \item \code{MP_A: } A \code{numeric} vector. The measurement
#'                     results from IVD-MD \code{MP_A} (response).
#'               \item \code{MP_B: } A \code{numeric} vector. The measurement
#'                     results from IVD-MD \code{MP_B} (predictor).
#'               
#'             }
#' @param silence An \code{integer}. Controls verbose. Verbose can be either
#'                informative or just noise. Keep in mind that printing to
#'                the console will slow down calcuation drastically.
#'                \itemize{
#'                   \item \code{1: } All progress reports are silenced. This is the default.
#'                   \item \code{0: } Estimation steps and temporary results are printed to the console
#'                   \item \code{< 0: } Debugging. Expert use only.
#'                }
#'                
#' @description
#' Estimates the magnitude of differences in non-selectivity (DINS) in a
#' IVD-MD comparison between \code{MP_A} and \code{MP_B}. The parameter
#' \eqn{\zeta} measures DINS and is estimated using \eqn{\hat{\zeta}}. See
#' details.
#' 
#' @details
#' Differences in non-selectivity (DINS) between in vitro diagnostic medical
#' devices (IVD-MDs) may cause problems in e.g., evaluation of commutability
#' of external quality assessment materials or certified reference materials. 
#' A large value of \eqn{\hat{\zeta}} may indicate an unacceptable magnitude of
#' DINS between compared IVD-MDs. The estimator is defined by
#' 
#' \eqn{\hat{\zeta} = \frac{S^2 \cdot (nR + 2) / nR}
#' {\hat{\sigma}_v^2 + b_1^2 \cdot \hat{\sigma}_h^2}},
#' 
#' where:
#' \itemize{
#'   \item \eqn{S^2}: The estimated residual variance of the regression model
#'   \item \eqn{b_1^2}: The square of the slope estimator of the regression
#'         model.
#'   \item \eqn{\hat{\sigma}_v^2}: The estimated pooled repeatability variance
#'         of \code{MP_A}.
#'   \item \eqn{\hat{\sigma}_h^2}: The estimated pooled repeatability variance
#'         of \code{MP_B}.
#'   \item \eqn{n}: The number of unique clinical samples in \code{data}
#'   \item \eqn{R}: A suitable statistic (e.g., mean) of the number of
#'         replicated measurements performed on each clinical sample in
#'         \code{data}.
#' }
#' 
#' See references for finer details. This estimator of \eqn{\zeta} utilizes
#' the ordinary least squares regression model. Thus, it is sensitive to
#' non-linearity, which may or may not be due to systematic differences in
#' non-selectivity.
#' 
#' To mitigate model endogeneity effects from measurement error in the
#' predictor, the roles of \code{MP_A} and \code{MP_B} shifts if
#' 
#' \eqn{\lambda = \hat{\sigma}_v^2 / \hat{\sigma}_h^2 < 0.5}.
#' 
#' Be careful using this estimator of \eqn{\zeta} if both
#' \eqn{\hat{\sigma}_v^2} and \eqn{\hat{\sigma}_h^2} are large and the domain of
#' the measurement results is very narrow.
#' 
#' Note: If the relationship between \code{MP_A} and \code{MP_B} is
#' non-linear, it is advisable to use \code{estimate_zeta_ss()} from the
#' \code{smooth.commutable} package instead.
#' 
#' @return
#' A \code{list} of length one. Contains \code{zeta}, which is a
#' \code{double}. This is the calculated \eqn{\hat{\zeta}}.
#'
#' @examples
#' # Required packages
#' library(fasteqa)
#' 
#' # Estimate zeta based on the raw data
#' zeta <- estimate_zeta_ols(test_data)$zeta
#' 
#' # The output
#' print(round(zeta, 2L))
#' 
#' # Log-transformed data
#' log_test_data <- test_data
#' log_test_data$MP_A <- log(log_test_data$MP_A)
#' log_test_data$MP_B <- log(log_test_data$MP_B)
#' 
#' # Estimate zeta based on the log-transformed data
#' zeta_log <- estimate_zeta_ols(log_test_data)$zeta
#' 
#' # The output
#' print(round(zeta_log, 2L))
#'
#' @references
#' Fauskanger P.K., et al. (2025) Quantification of Difference in
#' Nonselectivity Between In Vitro Diagnostic Medical Devices.
#' \emph{Biometrical Journal}. 67: e70032.
#' \url{https://doi.org/10.1002/bimj.70032}
#'
NULL

#' Estimate differences in non-selectivity with zeta using Deming regression
#' 
#' @title Estimate differences in non-selectivity with zeta using Deming regression
#' @name estimate_zeta_deming
#' @param data \code{list} or \code{data table} - Data with elements/columns \code{SampleID}, \code{ReplicateID}, \code{MP_A} and \code{MP_B}
#' @param silence \code{integer} - How much progress reports should be returned. Note that returning progress reports will slow down the performance drastically. There are three valid inputs:
#' \itemize{
#'   \item \code{1: } All progress reports are silenced. This is the default.
#'   \item \code{0: } Estimation steps and temporary results are printed to the console.
#'   \item \code{< 0: } Debugging. Expert use only.
#' }
#' 
#' @description Estimate the degree of differences in non-selectivity with zeta. Zeta is is the ratio of the pooled average prediction error variance and the sum of analytical variances.  
#' 
#' @details Differences in non-selectivity between measurement systems may cause problems in e.g., evaluation of commutability. A large value of zeta indicates that we have have large differences in non-selectivity between compared measurement systems. An upper limit of acceptable zeta may be determined based on the allowable increase in prediction interval width and analyte of relevance
#' 
#' @return A list with the point estimate of zeta. The zeta value is a double value, meaning that the precision is 1e-6 (six decimals precision).
#'
#' @examples
#' 
#' # Estimate zeta for a particular dataset
#' zeta <- estimate_zeta_deming(test_data)$zeta
#' print(round(zeta, 2L))
#' 
#' # Estimate zeta based on log-transformed data
#' log_test_data <- test_data
#' log_test_data$MP_A <- log(log_test_data$MP_A)
#' log_test_data$MP_B <- log(log_test_data$MP_B)
#' zeta_log <- estimate_zeta_deming(log_test_data)$zeta
#' print(round(zeta_log, 2L))
#' 
NULL

estimate_zeta_ols <- function(data, silence = 1L) {
    .Call(`_fasteqa_estimate_zeta_ols`, data, silence)
}

estimate_zeta_deming <- function(data, silence = 1L) {
    .Call(`_fasteqa_estimate_zeta_deming`, data, silence)
}

#' @title Estimate a Statistic for Each Sample
#' @name fun_of_replicates
#'
#' @param data A \code{data.table} or \code{list} object. Must contain
#'        \code{SampleID}, \code{ReplicateID}, \code{MP_A} and \code{MP_B}.
#' @param fun A \code{character} string. Which statistic is to be calculated for
#'        each SampleID. Possible choices include \code{mean}, \code{var} (variance),
#'        \code{sd} (standard deviaton), \code{cv} (coefficient of variation),
#'        \code{median}, \code{min} (minimum) and \code{max} (maximum).
#'
#' @description
#' For each sample, uses the replicated measurements to estimate
#' a given statistic.
#'
#' @details
#' This function handles \code{NA}-values automatically. If all replicated measurements
#' for a given sample are \code{NA}-values, the corresponding estimated statistic will also
#' be \code{NA}. 
#'
#' @return
#' A \code{list} with elements \code{SampleID}, \code{MP_A} and \code{MP_B}.
#' \code{MP_A} and \code{MP_B} contains the estimated sample-wise statistics.
#'
#' @examples \dontrun{
#'   library(fasteqa)
#'   test_data <- simulate_eqa_data(list(n = 25, R = 5, cvx = 0.01,
#'                                       cvy = 0.01, cil = 2, ciu = 10))
#'   print(as.data.frame(fun_of_replicates(test_data, "mean")))
#'   print(as.data.frame(fun_of_replicates(test_data, "var")))
#'   print(as.data.frame(fun_of_replicates(test_data, "cv")))
#' }
fun_of_replicates <- function(data, fun = "mean") {
    .Call(`_fasteqa_fun_of_replicates`, data, fun)
}

#' @title Calculate Repeatability Variability Components for a Particular IVD-MD Comparison
#' @name global_precision_estimates
#' 
#' @param data A \code{list} or \code{data.table}. Must contain the following
#'             variables:
#'             \itemize{
#'               \item \code{SampleID: } A \code{character} vector. The sample
#'                                       identifiers.
#'               \item \code{ReplicateID: } A \code{character} vector. The
#'                                          replicate measurement identifiers.
#'               \item \code{MP_A: } A \code{numeric} vector. The measurements
#'                                   from IVD-MD \code{MP_A} (response).
#'               \item \code{MP_B: } A \code{numeric} vector. The measurements
#'                                   from IVD-MD \code{MP_B} (predictor).
#'             }
#'             
#' @description
#' Calculate various repeatability components, such as variance, coefficient
#' of variability and the ratio of variances.
#' 
#' @details
#' Five statistics are estimated. The repeatability variances of \code{MP_A}
#' and \code{MP_B} are estimated by calculating the \eqn{n} (number of
#' unique values in \code{SampleID}) sample variances using the \code{numeric}
#' values in \code{MP_A} and \code{MP_B}. Then we take the mean of the sample
#' variances to obtain pooled estimated variances for the true repeatability
#' variances. We denote these estimated pooled variances by \code{Var_A} and
#' \code{Var_B}, respectively. Using the grand mean of \code{MP_A} and
#' \code{MP_B} we can then calculate three other statistics, \code{CV_A},
#' \code{CV_B} and \code{lambda}. Here is a summary the different estimated
#' statistics:
#' \itemize{
#'   \item \code{Var_A: } Pooled variance of all samplewise variances based on
#'                        IVD-MD \code{MP_A}. An estimator for
#'                        \eqn{\sigma_v^2}. Denote the estimator
#'                        \eqn{\hat{\sigma}_v^2}
#'   \item \code{Var_B: } Pooled variance of all samplewise variances based on
#'                        IVD-MD \code{MP_B}. An estimator for
#'                        \eqn{\sigma_h^2}. Denote the estimator
#'                        \eqn{\hat{\sigma}_h^2}
#'   \item \code{CV_A: } Estimated repeatbility coefficient of variation.
#'                       calculated by \eqn{\hat{\sigma}_v / \overline{y}},
#'                       where \eqn{\overline{y}} is the grand sample mean of
#'                       the values in \code{MP_A}.
#'   \item \code{CV_B: } Estimated repeatbility coefficient of variation.
#'                       calculated by \eqn{\hat{\sigma}_h / \overline{x}},
#'                       where \eqn{\overline{x}} is the grand sample mean of
#'                       the values in \code{MP_B}.
#'   \item \code{lambda: } Estimated repeatbility variance ratio. 
#'                         calculated by
#'                         \eqn{\hat{\sigma}_v^2 / \hat{\sigma}_h^2}.
#' }
#' 
#' By default, \code{CV_A} and \code{CV_B} are represented as a decimal
#' number. These values can also be represented as percentages, and to
#' covert to percentages, one should multiply their raw values with \code{100}.
#' 
#' Note: If one uses log-transformed \code{data}, the interpretation of
#' \code{CV_A} and \code{CV_B} may change, depending on the application.
#' In the log-transformation case, the square-root of \code{Var_A} and
#' \code{Var_B} have a similar interpretation as \code{CV_A} and \code{CV_B}
#' calculated using raw \code{data}.
#' 
#'
#' @return
#' A \code{list} of length five. Each element contains the an estimated
#' statistic. See details for information on each of them.
#' 
#' @examples
#' library(fasteqa)
#' # Calculate imprecision estimates
#' repeatability_statistics <- global_precision_estimates(test_data)
#' 
#' # Output
#' print(repeatability_statistics)
#' 
#' # Convert CV_A and CV_B to percentages
#' repeatability_statistics$CV_A <- repeatability_statistics$CV_A * 100
#' repeatability_statistics$CV_B <- repeatability_statistics$CV_B * 100
#' 
#' # Round results (two decimals)
#' repeatability_statistics <- lapply(X = repeatability_statistics,
#'                                    FUN = round,
#'                                    digits = 2L)
#' 
#' # Convert to data.frame
#' repeatability_statistics <- as.data.frame(repeatability_statistics)
#' 
#' print(repeatability_statistics)
#' 
NULL

global_precision_estimates <- function(data) {
    .Call(`_fasteqa_global_precision_estimates`, data)
}

#' Merge all commutability evaluation computations efficiently into one object
#' 
#' @title Merge all computations efficiently into one object
#' @name merge_results
#' @param pb_data A \code{list} or \code{data.table}. This should contain the
#'        prediction band data. Estimated prediction band data is a collection
#'        of estimated pointwise prediction intervals evaluated along a given
#'        grid of predictor values. Must contain:
#'        \itemize{
#'           \item \code{comparison: } A \code{character} vector. The
#'                                     comparison identifiers. Typically on
#'                                     the form MP_A - MP_B.
#'           \item \code{predictor: } A \code{numeric} vector. The \code{MP_B}
#'                                    values used to predict the \code{MP_A}
#'                                    values based on the model.
#'           \item \code{prediction: } A \code{numeric} vector. The predicted
#'                                     \code{MP_A} values based on the
#'                                     predictor values \code{MP_B}.
#'           \item \code{lwr: } A \code{numeric} vector. The lower bound of the
#'                              pointwise prediction intervals.
#'           \item \code{upr: } A \code{numeric} vector. The upper bound of the
#'                              pointwise prediction intervals.
#'        }
#' @param ce_data A \code{list} or \code{data.table}. This should contain the
#'                estimated prediction intervals for evaluated data along with
#'                observed values of \code{MP_B} and \code{MP_B}.
#'                Must contain:
#'                \itemize{
#'                   \item \code{comparison: } A \code{character} vector. The
#'                                             comparison identifiers.
#'                                             Typically on the form
#'                                             \code{'MP_A - MP_B'}.
#'                   \item \code{SampleID: } A \code{character} vector. The
#'                                           sample identifiers for the
#'                                           evaluated samples.
#'                   \item \code{MP_A: } A \code{numeric} vector. The observed
#'                                       measurement results from IVD-MD
#'                                       \code{MP_A} (response).
#'                   \item \code{MP_B: } A \code{numeric} vector. The observed
#'                                       measurement results from IVD-MD
#'                                       \code{MP_B} (predictor).
#'                   \item \code{prediction: } A \code{numeric} vector. The
#'                                             predicted values of \code{MP_A}
#'                                             based on \code{MP_B}.
#'                   \item \code{lwr: } A \code{numeric} vector. The lower
#'                                      bound of the prediction intervals of
#'                                      \code{MP_A}.
#'                   \item \code{upr: } A \code{numeric} vector. The upper
#'                                      bound of the prediction intervals of
#'                                      \code{MP_A}.
#'                   \item \code{inside: } An \code{integer} vector. Should be
#'                                         \code{1} if \code{MP_A}
#'                                         \eqn{\in [\mathrm{lwr},
#'                                         \mathrm{upr}]}, and \code{0}
#'                                         otherwise.
#'                }
#' @param zeta_data A \code{list} or \code{data.table}. This should contain
#'                  relevant statistics of \eqn{\hat{\zeta}}. Must contain:
#'                  \itemize{
#'                     \item \code{comparison: } A \code{character} vector.
#'                                               The comparison identifiers.
#'                                               Typically on the form
#'                                               \code{'MP_A - MP_B'}.
#'                     \item \code{zeta: } A \code{numeric} vector. The
#'                                         point estimates of \eqn{\zeta}.
#'                                         Calculated using
#'                                         \code{estimate_zeta()} or
#'                                         \code{estimate_zeta_ss()}
#'                                         (\code{smooth.commutability}
#'                                         package).
#'                     \item \code{lwr: } A \code{numeric} vector. The lower
#'                                        bound of an estimated confidence
#'                                        interval for \eqn{\hat{\zeta}}.
#'                     \item \code{upr: } A \code{numeric} vector. The upper
#'                                        bound of an estimated confidence
#'                                        interval for \eqn{\hat{\zeta}}.
#'                     \item \code{zeta_critical: } A \code{numeric} vector.
#'                                                  The largest value
#'                                                  \eqn{\hat{\zeta}} can take
#'                                                  to conclude that a
#'                                                  particular IVD-MD
#'                                                  comparison hav acceptable
#'                                                  differences in 
#'                                                  non-selectivity.
#'                     \item \code{zeta_conclusion: } An \code{integer} vector.
#'                                                    Should be \code{1} if
#'                                                    \code{zeta} \eqn{\geq}
#'                                                    \code{zeta_critical} and
#'                                                    \code{0} otherwise.
#'                  }
#' @param imprecision_data A \code{list} or \code{data.table}. Repeatability
#'                         uncertainty estimates and corresponding confidence
#'                         intervals. Must contain:
#'                         \itemize{
#'                             \item \code{comparison: } A \code{character}
#'                             vector. The comparison identifiers. Typically
#'                             on the form \code{'MP_A - MP_B'}.
#'                             \item \code{CV_A: } A \code{numeric} vector.
#'                             The point estimates of the coefficient of
#'                             variability for the repeatability in
#'                             \code{MP_A}.
#'                             \item \code{CV_A_lwr: } A \code{numeric} vector.
#'                             The lower bounds of a confidence interval of
#'                             the coefficient of variability for the
#'                             repeatability in \code{MP_A}.
#'                             \item \code{CV_A_upr: } A \code{numeric} vector.
#'                             The upper bounds of a confidence interval of
#'                             the coefficient of variability for the
#'                             repeatability in \code{MP_A}.
#'                             \item \code{CV_B: } A \code{numeric} vector.
#'                             The point estimates of the coefficient of
#'                             variability for the repeatability in
#'                             \code{MP_B}.
#'                             \item \code{CV_B_lwr: } A \code{numeric} vector.
#'                             The lower bounds of a confidence interval of
#'                             the coefficient of variability for the
#'                             repeatability in \code{MP_B}.
#'                             \item \code{CV_B_upr: } A \code{numeric} vector.
#'                             The upper bounds of a confidence interval of
#'                             the coefficient of variability for the
#'                             repeatability in \code{MP_B}.
#'                             \item \code{lambda: } A \code{numeric} vector.
#'                             The point estimates of the repeatability
#'                             variance ratio between \code{MP_A} and
#'                             \code{MP_B}.
#'                             \item \code{lambda_lwr: } A \code{numeric}
#'                             vector. The lower bounds of a confidence
#'                             interval of \code{lambda}.
#'                             \item \code{lambda_upr: } A \code{numeric}
#'                             vector. The upper bounds of a confidence
#'                             interval of \code{lambda}.
#'                         }
#'                         This can be omitted.
#' @param rounding An \code{integer}. The maximum number of decimals to use
#'                 for the output \code{numeric} values. 
#' @param include_imprecision_estimates An \code{logical} value. If
#'                                      \code{TRUE}, imprecision estimate are
#'                                      included in the output. In this case,
#'                                      \code{imprecision_data} cannot be
#'                                      omitted.
#' @param silence An \code{integer}. Set to \eqn{\leq} \code{0} to allow
#'                verbose.
#' 
#' @description
#' Merge all the essential components for a complete commutability evaluation
#' data analysis. This merging allows for presenting the commutability
#' evaluation results in both plots and tables. 
#' 
#' @details
#' The merging is done with respect to the \code{comparison} column. Hence,
#' \code{comparison} must be part of all input components (i.e.,
#' \code{pb_data}, \code{ce_data}, \code{zeta_data}, \code{imprecision_data}).
#' 
#' In practice, this function results in two merged datasets.
#' 
#' (1) \code{ pb_data} is merged with \code{zeta_data} and
#' \code{imprecision_data}, using \code{comparison} as the key for the merging
#' process. The output will be a new \code{pb_data} that contain relevant
#' information from \code{zeta_data} and \code{imprecision_data}.
#' 
#' (2) \code{ ce_data} is merged with \code{zeta_data} and
#' \code{imprecision_data}, using \code{comparison} as key for the merging
#' process. The output will be a new \code{ce_data} that contain relevant
#' information from \code{zeta_data} and \code{imprecision_data}.
#' 
#' @return
#' A \code{list} of length two:
#' \itemize{
#'   \item \code{pb_data: } The input \code{pb_data} with additional elements
#'                          added in the merging process with \code{zeta_data}
#'                          and \code{imprecision_data}.
#'   \item \code{ce_data: } The input \code{ce_data} with additional elements
#'                          added in the merging process with \code{zeta_data}
#'                          and \code{imprecision_data}
#' } 
#'
#' @examples \dontrun{
#'   library(fasteqa)
#'   data <- simulate_data_eqa(list(n = 25, R = 3, cvx = 0.06, cvy = 0.04))
#'   estimate_zeta(data)
#' }
#'
NULL

merge_results <- function(pb_data, ce_data, zeta_data, imprecision_data = NULL, rounding = 3L, include_imprecision_estimates = TRUE, silence = 1L) {
    .Call(`_fasteqa_merge_results`, pb_data, ce_data, zeta_data, imprecision_data, rounding, include_imprecision_estimates, silence)
}

#' @title Prediction Interval Estimation for EQA Data via Deming or
#'        OLS Regression
#' @name predict_eqa
#'
#' @description
#' This function estimates prediction intervals for evaluated material data by
#' applying either Deming (\code{method = 'fg'} or \code{method = 'clsi'}) or
#' Ordinary Least Squares (\code{method = 'ols'}) regression methodologies.
#'
#' @param data A \code{list} or \code{data.table}. Must contain:
#'             \itemize{
#'                 \item \code{SampleID: } A \code{character} vector. The
#'                 clinical sample identifiers.
#'                 \item \code{MP_A: } A \code{numeric} vector. The means of
#'                 replicated measurements from IVD-MD \code{MP_A} (response).
#'                 \item \code{MP_B: } A \code{numeric} vector. The means of
#'                 replicated measurements from IVD-MD \code{MP_B} (predictor).
#'             }
#' @param new_data A \code{list} or \code{data.table}. Can contain:
#'                 \itemize{
#'                     \item \code{SampleID: } A \code{character} vector. The
#'                     evaluated material sample identifiers. Optional.
#'                     \item \code{MP_A: } A \code{numeric} vector. The means
#'                     of replicated measurements from IVD-MD \code{MP_A}.
#'                     Optional.
#'                     \item \code{MP_B: } A \code{numeric} vector. The means
#'                     of replicated measurements from IVD-MD \code{MP_B}.
#'                     Mandatory.
#'                 }
#'                 The structure of \code{new_data} determines the output
#'                 type. For constructing prediction band (PB) data, include
#'                 only \code{MP_B}. For constructing commutability
#'                 evaluation data, include all three. Inside checks can only
#'                 be performed if \code{MP_A} is included.
#'                
#' @param imprecision_estimates A \code{list} or \code{data.table}. Must
#'                              include:
#'                              \itemize{
#'                                 \item \code{Var_B: } Pooled variance 
#'                                       estimate of \eqn{\sigma_h^2}.
#'                                 \item \code{lambda: } Estimate of
#'                                       \eqn{\sigma_v^2 / \sigma_h^2}. 
#'                              }
#'                              See details.
#' @param R An \code{integer}. The average number of replicates on which
#'          \code{new_data} is based. \code{count_samplewise_replicates()} can
#'          be employed to generate a suitable input for this parameter
#'          directly.
#' @param R_ratio A \code{double}. The ratio of the number of replicates used
#'                in \code{new_data} and \code{data}. Only relevant if
#'                \code{method = 'fg'} or \code{method = 'ols'}. Defaults to
#'                \code{1L}.
#' @param method A \code{character} string. The desired method for estimating
#'               prediction intervals. Possible prediction estimation
#'               approaches includes:
#'               \itemize{
#'                   \item \code{fg: } Implements standard Deming regression
#'                         with prediction intervals calculated using the
#'                         'Fuller & Gillard' approach. See details.
#'                   \item \code{clsi: } Utilizes standard Deming regression,
#'                         with prediction intervals derived from the CLSI
#'                         method. See details.
#'                   \item \code{ols: } Implements Ordinary Least Squares
#'                         regression.
#'               }
#' @param level A \code{double}. Must be between \code{0} and \code{1}. The
#'              nominal confidence level for the estimated prediction
#'              intervals. Defaults to \code{0.99} (\eqn{99\%}).
#' @param allow_reverse_regression A \code{logical} value. If \code{TRUE} and
#'                                 \code{method = 'ols'}, the response and
#'                                 predictor change roles if
#'                                 \code{lambda < 0.5}. Defaults to
#'                                 \code{FALSE}.
#' @param rounding An \code{integer}. The desired number of decimal places for
#'                 the predictions and prediction intervals. Defaults to
#'                 \code{3L}, offering sufficient precision in relevant
#'                 applications.
#'
#' @details
#' For commutability evaluation purposes, inclusion of all \code{SampleID},
#' \code{MP_A}, and \code{MP_B} in \code{new_data} is required. 
#' If only prediction band data is required, inclusion of \code{MP_B} in
#' \code{new_data} is the sole requirement.
#' 
#' Imprecision Estimates
#' 
#' Estimating prediction intervals may require certain imprecision estimates,
#' which can be estimated from the raw data. Which imprecision estimates that
#' are required depends on which method that is used to construct the
#' prediction intervals. For \code{method = 'fg'} or \code{method = 'ols'},
#' \code{lambda} is required. \code{lambda} is calculated using
#' 
#' \eqn{\lambda = \frac{\hat{\sigma}_v^2}{\hat{\sigma}_h^2}},
#' 
#' where \eqn{\hat{\sigma}_v^2} and \eqn{\hat{\sigma}_h^2} are pooled 
#' variance estimates. If differences in non-selectivity (DINS) or equation
#' error cannot be ruled out, \eqn{\lambda} will generally underestimate the
#' true parameter \eqn{\Lambda}. Keep this in mind!
#' 
#' For \code{method = 'clsi'}, both \code{Var_B} and \code{lambda} are
#' required. \code{lambda} is calculated as before, and \code{Var_B} is just
#' \eqn{\hat{\sigma}_h^2}.
#' 
#' Note that both \code{lambda} and \code{Var_B} always must be given as
#' input. However, if one of them is not necessary to estimate prediction
#' intervals, it may take an arbitrary value. It is nevertheless recommended
#' to always include actual values \code{lambda} and \code{Var_B},
#' independently of whether they are actual used or not.
#' 
#' Note also that \code{global_precision_estimates()} can be used to calculate
#' both \code{lambda} and \code{Var_B}.
#' 
#' @return 
#' A \code{list}. The resulting estimated prediction interval data based on
#' the function inputs. Contain the following elements:
#' \itemize{
#'     \item \code{SampleID: } A \code{character} vector. The ID(s) of the
#'           evaluated material(s).
#'     \item \code{MP_B: } A \code{numeric} vector. The measurement result(s)
#'           of IVD-MD \code{MP_B} (predictor).
#'     \item \code{MP_A: } A \code{numeric} vector. The measurement result(s)
#'           of IVD-MD \code{MP_A} (response).
#'     \item \code{prediction: } A \code{numeric} vector. The predicted
#'           value(s) of \code{MP_A} given the value(s) of \code{MP_B}.
#'     \item \code{lwr: } A \code{numeric} vector. The lower limit(s) of the
#'           estimated prediction interval(s) of \code{MP_A} given the
#'           value(s) of \code{MP_B}.
#'     \item \code{upr: } A \code{numeric} vector. The upper limit(s) of the
#'            estimated prediction interval(s) of \code{MP_A} given the
#'            value(s) of \code{MP_B}.
#'     \item \code{inside: } An \code{integer} vector. The Inside checks.
#'           \code{1} if \code{MP_A} is inside the estimated prediction
#'           interval for \code{MP_A}. Otherwise, \code{0}.
#' }
#' Note: the output \code{list} may be converted to \code{data.table} by using
#' the \code{setDT()} function from the \code{data.table} package in R.
#'
#' @examples
#' # Required packages
#' library(fasteqa)
#' library(data.table)
#' 
#' # Read data and convert to data.table
#' test_data_example <- as.data.table(test_data)
#' 
#' # Log-transform data
#' test_data_example[, MP_A := log(MP_A)]
#' test_data_example[, MP_B := log(MP_B)]
#' 
#' # Use one of the clinical samples as a fictive evaluated material sample
#' test_cs_data <- test_data_example[SampleID != "1"]
#' test_eq_data <- test_data_example[SampleID == "1"]
#' 
#' # Estimate repeatability uncertainty statistics
#' impr_data <- global_precision_estimates(test_cs_data)
#' 
#' # Calculate mean-of-replicates data
#' test_cs_data <- test_cs_data[, fun_of_replicates(.SD)]
#' test_eq_data <- test_eq_data[, fun_of_replicates(.SD)]
#' 
#' # Calculate 95% OLS commutability evaluation data
#' ols_pi <- predict_eqa(data = test_cs_data,
#'                       new_data = test_eq_data,
#'                       imprecision_estimates = impr_data,
#'                       method = "ols",
#'                       level = 0.95,
#'                       allow_reverse_regression = FALSE,
#'                       rounding = 3L)
#' 
#' # Calculate 95% F-G Deming commutability evaluation data
#' fg_pi <- predict_eqa(data = test_cs_data,
#'                      new_data = test_eq_data,
#'                      imprecision_estimates = impr_data,
#'                      method = "fg",
#'                      level = 0.95,
#'                      allow_reverse_regression = FALSE,
#'                      rounding = 3L)
#' 
#' # Calculate 95% CLSI EP14 Deming commutability evaluation data
#' clsi_pi <- predict_eqa(data = test_cs_data,
#'                       new_data = test_eq_data,
#'                       imprecision_estimates = impr_data,
#'                       method = "clsi",
#'                       level = 0.95,
#'                       allow_reverse_regression = FALSE,
#'                       rounding = 3L)
#' 
#' # Convert to data.table objects
#' lapply(X = list(ols_pi,
#'                 fg_pi,
#'                 clsi_pi),
#'        FUN = setDT)
#' 
#' # Gather into one data.table
#' pis <- rbindlist(list("ols" = ols_pi,
#'                       "fg" = fg_pi,
#'                       "clsi" = clsi_pi),
#'                   idcol = "method")
#' 
#' # The result                  
#' print(pis)
#' 
NULL

predict_eqa <- function(data, new_data, imprecision_estimates, R = 3L, R_ratio = 1, method = "fg", level = 0.99, allow_reverse_regression = TRUE, rounding = 3L) {
    .Call(`_fasteqa_predict_eqa`, data, new_data, imprecision_estimates, R, R_ratio, method, level, allow_reverse_regression, rounding)
}

#' @title Calculate Model Residuals for External Quality Assessment Data
#' @name residuals_eqa
#' 
#' @param data A list or data.table containing:
#'        \itemize{
#'           \item \code{SampleID}: A \code{character} vector of sample identifiers
#'           \item \code{MP_A}: A \code{numeric} vector of measurements from method A (response)
#'           \item \code{MP_B}: A \code{numeric} vector of measurements from method B (predictor)
#'        }
#' @param imprecision_estimates A \code{list} or \code{data.table} containing
#'        \itemize{
#'           \item \code{lambda}: A positive numeric value representing the repeatability
#'                                variance ratio between response and predictor.
#'        }
#'        Can be calculated using the \code{global_precision_estimates()} function.
#' @param method A \code{character} string specifying the linear regression model
#'        applied for obtaining the residuals and fitted values.  Options are:
#'        \itemize{
#'           \item \code{'fg'} (default): Deming regression, incorporating results from W. Fuller and J. Gillard.
#'           \item \code{'clsi'}: Deming regression based on the CLSI EP14 standard.
#'           \item \code{'ols'}: Ordinary Least Squares regression.
#'        }
#' @param studentize A non-missing \code{logical} value. If \code{TRUE} (default),
#'        the standardized residuals are computed. Here, this means that the sample mean
#'        of the residuals is subtracted from each residual and this result is divided by
#'        the sample standard deviation of the residuals. Raw residuals are returned
#'        if this is set to \code{FALSE}. Standardized residuals can be
#'        beneficial if one requires to compare the residuals' distribution to the standard
#'        normal distribution or a particular student t-distribution.
#' 
#' @param unit_sd A non-missing \code{logical} value. If \code{TRUE}, the standard
#'        deviation of the residuals are assumed to be equal to \code{1}. 
#'        
#' @param invalid_NA A non-missing \code{logical} value. If \code{TRUE},
#'        a \code{list} is \code{NA}-values is returned instead of throwing
#'        an error.
#'
#' @description
#' This function computes residuals and fitted values for external quality assessment (EQA)
#' clinical sample data using various regression methods. It is designed to work with
#' paired measurement results from two in vitro diagnostic medical devices (IVD-MDs).
#'
#' @details
#' The function handles missing values by removing them before calculations. It supports
#' three regression methods, each with slightly different approaches to calculating residuals
#' and fitted values. The \code{'fg'} method is generally recommended.
#' While the outcome differences between the three avaiable methods may be small,
#' they can still be noteworthy in some cases. 
#'
#' @return 
#' This function returns a \code{list} comprising two \code{numeric} vectors named
#' \code{residuals} and \code{fitted}. These are the residuals and fitted values, respectively,
#' based on the input \code{data}, \code{imprecision_estimates}, and \code{method}.
#'
#' @examples \dontrun{
#'   library(fasteqa)
#'   parameters <- list(n = 20, R = 3, cvx = 0.03, cvy = 0.02, cil = 10, ciu = 15)
#'   data <- simulate_eqa_data(training_parameters)
#'   data$SampleID <- as.character(data$SampleID)
#'   data$ReplicateID <- as.character(data$ReplicateID)
#'   imprecision <- global_precision_estimates(data)
#'   mean_of_replicates_data <- fun_of_replicates(data)
#'   # Extracting raw residuals based on the clsi Deming regression approach
#'   residuals_eqa(mean_of_replicates_data, imprecision, "clsi", 0)
#' }
#' 
#' @seealso
#' \code{\link{global_precision_estimates}} for calculating imprecision estimates
#' 
#' @references
#' Fuller, W. A. (1987). Measurement Error Models. John Wiley & Sons.
#' 
#' Gillard J. W. (2010). An Overview of Linear Structural Models in Errors in
#' Variables Regression. REVSTAT-Statistical Journal 8(1), 57-80
#' 
NULL

residuals_eqa <- function(data, imprecision_estimates, method = "fg", studentize = TRUE, unit_sd = FALSE, invalid_NA = FALSE) {
    .Call(`_fasteqa_residuals_eqa`, data, imprecision_estimates, method, studentize, unit_sd, invalid_NA)
}

#' @title Simulation of External Quality Assessment (EQA) Data (Deprecated)
#' @name simulate_eqa_data
#' 
#' @param parameters A \code{list} of parameters used to simulate the EQA data.
#'        You must at least specify one parameter for this function to run.
#'        Except that one mandatory parameter, you may optionally choose the
#'        remaining of the parameters. These are the optimal parameters that you may include into the list:
#' \itemize{
#'   \item \code{n: } The number of clinical samples
#'   \item \code{R: } The number of replicates on each sample
#'   \item \code{cvx: } The analytical CV of x measurements
#'   \item \code{cvy: } The analytical CV of y measurements
#'   \item \code{cil: } The lower range of the concentration interval
#'   \item \code{ciu: } The upper range of the concentration interval
#'   \item \code{dist: } The distribution to simulate latent variables from.
#'                       Possbile choices include 'unif' 
#'                       (uniform distribution, default),
#'                       'norm' (normal distribution) ,
#'                       'lst' (location-scale student t-distribution),
#'                       'lnorm' (log-normal distribution)
#'   \item \code{df_tau: } The degrees of freedom for the 'lst' distribution
#'                         if the distribution of latent variables are
#'                         location-scale student t-distributed ('lst').
#'                         Defaults to 5 if not otherwise is specified.
#'   \item \code{eta: } The heteroscedasticity factor
#'   \item \code{eta0: } The proportion of "base standard deviation"
#'   \item \code{qpos: } Position of systematic differences in
#'                       non-selectivity. 0 signify lower concentration
#'                       interval and 1 signify upper concentration interval.
#'   \item \code{qran: } Interquantile range where systematic differences in
#'                       non-selectivity should have its effect
#'   \item \code{prop: } average proportion of clinical samples affected by
#'                       random differences in non-selectivity
#'   \item \code{mmax: } The maximum relocation magnitude multiplier.
#'   \item \code{b0: } For systematic linear bias between IVD-MDs.
#'                     The intercept. This defaults to 0.
#'   \item \code{b1: } For systematic linear DINS between IVD-MDs.
#'                     The slope. This defaults to 1.
#'   \item \code{c0: } For systematic linear non-selectivity in IVD-MD one.
#'                     The intercept. This defaults to 0.
#'   \item \code{c1: } For systematic linear non-selectivity in IVD-MD one.
#'                     The slope. This defaults to 1.
#'   \item \code{error_dist: } The distribution to simulate measurement error
#'                             components from. Possible choices include
#'                             'norm' (normal distribution, default) and 'lt'
#'                             (location student t-distribution)
#'   \item \code{dfx: } The degrees of freedom for the measurement error
#'                      components in IVD-MD one if \code{error_dist = 'lt'}.
#'                      Defaults to 5 if not otherwise is specified.
#'   \item \code{dfy: } The degrees of freedom for the measurement error
#'                      components in IVD-MD two if \code{error_dist = 'lt'}.
#'                      Defaults to 5 if not otherwise is specified.
#'   \item \code{md_method: } Method for simulation missing data. Possible
#'                            choices include 'none'
#'                            (no missing data is simulated, default),
#'                            'mar' (Missing at Random),
#'                            'mnar' (Missing Not at Random) and 
#'                            'marmnar' (Missing systematically and randomly)
#'   \item \code{mar_prob: } The probability (value between 0 and 1) of having
#'                           a missing measurement. Only relevant if
#'                           \code{md_method = 'mar'} or 
#'                           \code{md_method = 'marmnar'}. If not specified,
#'                           but \code{md_method  = 'mar'} or
#'                           \code{md_method = 'marmnar'}, it defaults to 0.05.
#'   \item \code{mnar_threshold: } The lower bound threshold (a real value)
#'                                 for when a measurement should be missing.
#'                                 Only relevant if \code{md_method = 'mnar'}
#'                                 or \code{md_method = 'marmnar'}. If not
#'                                 specified, but \code{md_method = 'mnar'} or
#'                                 \code{md_method = 'marmnar'}, it defaults
#'                                 to \code{cil}. Alternatively,
#'                                 if not specified,
#'                                 but \code{md_method = 'mnar0'} or
#'                                 \code{md_method = 'marmnar0'}, it defaults
#'                                 to 0.
#'   
#' }
#' @param silence \code{Integer} should temporary calculation results be
#'        printed? This may be useful for debugging or strange curiosity.
#'        \code{silence = 1} signify that printing will be suppressed,
#'        which is the default. \code{silence = 0} allows such printing. 
#' 
#' @description
#' (Deprecated) Simulates a dataset with at most n x R rows measurements.
#' 
#' @details
#' (Deprecated) Simulates method comparison data for \eqn{\leq} \code{n}
#' samples (e.g., clinical samples, pools, external quality assessment
#' samples, reference material samples), where each sample is measured
#' \eqn{\leq} \code{R} times (replicated measurements). In theory, we simulate
#' \eqn{(x_{ir}, y_{ir})} from
#' 
#' \eqn{x_{ir} = f(\xi_i) + h_{ir}, \newline
#'      y_{ir} = g(f(\xi_i)) + v_{ir}, \newline
#'      \tau_i = g(f(\xi_i)) = f(\xi_i) + e_{i}}.
#' 
#' If \eqn{f} is linear in \eqn{\xi_i}, we have that
#' \eqn{\tau_i = f(\xi_i) = c_0 + c_1 \cdot \xi_i + e_{i}}.
#' We generally do not care much about the shape of \eqn{f(\xi_i)}.
#' We are more interested in the values \eqn{\tau_i} and \eqn{g}. Assuming
#' that \eqn{g} is linear, we have that
#' \eqn{g(\tau_i) = \beta_0 + \beta_1 \cdot \tau_i + e_{i}}.
#' Thus, we simulate \eqn{(x_{ir}, y_{ir})} from
#' 
#' \eqn{x_{ir} = \tau_i + h_{ir}, \newline
#'      y_{ir} = g(\tau_i) + v_{ir}, \newline
#'      g(\tau_i) = \beta_0 + \beta_1 \cdot \tau_i + e_{i}}.
#' 
#' The form of \eqn{f} is specified through parameters \code{c0} and
#' \code{c1}, whereas \eqn{g} is specified through numerous parameters such as
#' \code{b0}, \code{b1}, \code{qpos}, \code{qran}, \code{mmax}, \code{prop}.
#' The latter four parameters influence the random variable \eqn{e_{i}}.
#' 
#' \eqn{\tau_i} is modelled through \code{cil}, \code{ciu}, \code{dist} and
#' \code{df_tau}. \eqn{h_{ir}} and \eqn{v_{ir}} are measurement error
#' components modelled through \code{cvx} and \code{cvy}. These coefficients
#' of variation, can be functions of \code{error_dist}, \code{dfx},
#' \code{dfy}, \code{eta} and \code{eta0}. 
#' In order to convert the outputted \code{list} to a data frame format,
#' use either \code{as.data.frame()}, \code{as.data.table()},
#' \code{as.tibble()}. The most efficient way 
#' 
#' This function is deprecated. Use \code{simulate_eqa_data_new()} instead.
#' It is kept to allow for reproducibility for some research.
#'
#' @return
#' A \code{list} of length 4:
#' \itemize{
#'   \item \code{SampleID:} An \code{integer} vector. Sample identifiers.
#'   \item \code{ReplicateID:} An \code{integer} vector. Replicate identifiers.
#'   \item \code{MP_A:} An \code{numeric} vector. Simulated measurements from
#'                      one of the IVD-MDs in comparison.
#'   \item \code{MP_B:} An \code{numeric} vector. Simulated measurements from
#'                      the other IVD-MD in comparison.
#' } 
#'
#' @examples \dontrun{
#'   
#'   # Load data.table package from library
#'   library(data.table)
#'   
#'   # Simulate 25 clinical samples measured in triplicate affected by
#'   # random differences in non-selectivity
#'   parameters_css <- list(n = 25, R = 3, prop = 0.1, mmax = 5, cil = 25, ciu = 75)
#'   simulated_css <- simulate_eqa_data(parameters = parameters_css)
#'   
#'   # Simulate 3 external quality assessment material samples
#'   # measured in duplicate not affected by differences in non-selectivity
#'   parameters_eqams <- list(n = 3, R = 2, b0 = 0.1, b1 = 1.1)
#'   simulated_eqams <- simulate_eqa_data(parameters = parameters_eqams)
#'   
#'   # We can assume that tau_i ~ lst(df_tau = 10, mu_tau = 50, var_tau = 78.583)
#'   parameters_css <- c(parameters_css, dist = "lst", df_tau = 10)
#'   simulated_css_lst <- simulate_eqa_data(parameters = parameters_css)
#'   
#'   # We can convert the list objects to data.table objects using setDT()
#'   setDT(simulated_css)
#'   setDT(simulated_eqams)
#'   setDT(simulated_css_lst)
#'   
#'   # Print results
#'   print(simulated_css)
#'   print(simulated_eqams)
#'   print(simulated_css_lst)
#'   
#' }
#'
NULL

#' @title Simulation of External Quality Assessment (EQA) Data
#' @name sim_eqa_data
#'
#' @param parameters A \code{list} of parameters and their value. These values
#'        are used to simulate the EQA data. Optional parameters that you may
#'        include into the list are:
#' \itemize{
#'   \item \code{n: } The number of samples.
#'   \item \code{R: } The number of replicates on each sample.
#'   \item \code{cvx: } The repeatability coefficient of variation for IVD-MD 
#'                      \code{MP_B}.
#'   \item \code{cvy: } The repeatability coefficient of variation for IVD-MD
#'                      \code{MP_A}.
#'   \item \code{cil: } The lower bound of the concentration interval.
#'   \item \code{ciu: } The upper bound of the concentration interval.
#'   \item \code{dist: } The distribution to simulate latent variables from.
#'                       Possbile choices include
#'                       \code{unif} (uniform distribution, default),
#'                       \code{norm} (normal distribution),
#'                       \code{lst} (location-scale student t-distribution),
#'                       \code{lnorm} (log-normal distribution).
#'   \item \code{df_tau: } The degrees of freedom for the \code{lst}
#'                         distribution if the distribution of latent variables
#'                         are location-scale student t-distributed ('lst').
#'                         Defaults to \eqn{5} if not otherwise is specified.
#'   \item \code{eta: } The heteroscedasticity factor \eqn{\eta}.
#'   \item \code{eta0: } The proportion of "base standard deviation". See
#'                       details.
#'   \item \code{qpos: } Position of systematic differences in non-selectivity.
#'                       \code{0} signify lower concentration interval and
#'                       \code{1} signify upper.
#'   \item \code{qran: } Interquantile range where systematic differences in
#'                       non-selectivity should have its effect
#'   \item \code{prop: } average proportion of clinical samples affected by
#'                       random differences in non-selectivity.
#'   \item \code{mmax: } The maximum relocation magnitude multiplier,
#'                       \eqn{m_{\max}}. This number is a multiplier of the
#'                       base standard deviation. This will only have an effect
#'                       if \code{prop}, or \code{qpos} and \code{qran} are
#'                       specified as well.
#'   \item \code{b0: } For systematic linear bias between IVD-MDs.
#'                     The intercept. Defaults to 0.
#'   \item \code{b1: } For systematic linear bias between IVD-MDs. The 
#'                     slope. Defaults to 1.
#'   \item \code{c0: } For systematic linear non-selectivity in IVD-MD 1.
#'                     The intercept. Defaults to 0.
#'   \item \code{c1: } For systematic linear non-selectivity in IVD-MD 1.
#'                     The slope. Defaults to 1.
#'   \item \code{error_dist: } The distribution to simulate measurement error
#'                             components from. Possible choices include 'norm'
#'                             (normal distribution, default) and
#'                             'lt' (location student t-distribution).
#'   \item \code{dfx: } The degrees of freedom for the measurement error
#'                      components in IVD-MD 1 if \code{error_dist = 'lt'}.
#'                      Defaults to \eqn{5} if not otherwise is specified.
#'   \item \code{dfy: } The degrees of freedom for the measurement error
#'                      components in IVD-MD 2 if \code{error_dist = 'lt'}.
#'                      Defaults to \eqn{5} if not otherwise is specified.
#'   \item \code{md_method: } Method for simulating missing data. Possible
#'                            choices include \code{'none'}
#'                            (no missing data is simulated, default),
#'                            \code{'mar'} (missing at random),
#'                            \code{'mnar'} (missing not at random) and
#'                            \code{'marmnar'}
#'                            (missing both at random and not at random)
#'   \item \code{mar_prob: } The probability (value between 0 and 1) of having
#'                           a missing measurement. Only relevant if
#'                           \code{md_method} is \code{'mar'} or
#'                           \code{'marmnar'}. If not specified, but 
#'                           \code{md_method = 'mar'} or
#'                           \code{md_method = 'marmnar'}, it defaults to 0.05.
#'   \item \code{mnar_threshold: } The lower bound threshold (\code{double})
#'                                 for when a measurement should be missing.
#'                                 Only relevant if \code{md_method} is
#'                                 \code{'mnar'} or \code{'marmnar'}. If not
#'                                 specified, but \code{md_method = 'mnar'}
#'                                 or \code{md_method = 'marmnar'}, it defaults
#'                                 to \code{cil}. Alternatively, if not
#'                                 specified, but \code{md_method = 'mnar0'}
#'                                 or \code{md_method = 'marmnar0'},
#'                                 it defaults to 0.
#'   \item \code{g: } A custom function to simulate \eqn{\mathrm{E}[y_{ir}]}
#'                    from. It is not recommended to use this for linear
#'                    \code{g}, because it is much slower. This is generally
#'                    used to simulate data from non-linear functions other
#'                    than the three built-in alternatives
#'                    (see \code{type} argument).
#'   \item \code{obs_tau: } A \code{numeric} vector of \eqn{\tau_i} values.
#'                          (true but latent values for IVD-MD one).
#'                          If this parameter is specified, \code{n} will take
#'                          the length of \code{obs_tau}. Moreover, all
#'                          parameters used to generate \eqn{\tau_i} are
#'                          ignored.
#' }
#' @param type A \code{integer}. Custom built-in functions \code{g}. Set to
#'        \code{0}, to use a linear \code{g}. Otherwise, particular custom
#'        non-linear functions can be used. The four different built-in
#'        \code{g}:
#'        \itemize{
#'           \item \code{type = 0: } \eqn{g(\tau_i) = \beta_0 + \beta_1 \cdot
#'                                        \tau_i}
#'           \item \code{type = 1: } \eqn{g(\tau_i) = \tau_i + 0.90 \cdot
#'                                        \mathrm{sin}(0.40 \cdot
#'                                        \tau_i ^ {1.06})}
#'           \item \code{type = 2: } \eqn{g(\tau_i) = \tau_i + 0.05 \cdot
#'                                        \exp(0.16 \cdot \tau_i ^ {1.35})}
#'           \item \code{type = 3: } \eqn{g(\tau_i) = \tau_i - \exp[
#'                                        -0.125 \cdot (\tau_i - 1.50)^2]}
#'        }
#'        If \code{g} exists in \code{parameters}, this argument is ignored.
#' @param AR A \code{logical} value. If \code{TRUE}, data is simulated including
#'        replicated measurements. Otherwise, mean of replicated measurements
#'        are returned (MOR).
#' @param include_parameters A \code{logical} value. If \code{TRUE}, the used
#'        parameters in the data simulation is saved and placed in a seperate
#'        list as part of the output.
#'
#' @description
#' Simulates a dataset with at most n x R rows measurements.
#' 
#' @details
#' Simulates method comparison data for \code{n} samples
#' (e.g., clinical samples, pools, external quality assessment samples, reference material samples),
#' where each sample is measured at most \code{R} times (replicated measurements).
#' In theory, we simulate measurement pairs \eqn{(x_{ir}, y_{ir})} from:
#' 
#' \eqn{x_{ir} = f(\xi_i) + h_{ir} \newline
#'      y_{ir} = g(f(\xi_i)) + v_{ir} \newline
#'      g(f(\xi_i)) = f(\xi_i) + e_{i}}.
#' 
#' If \eqn{f} is linear in \eqn{\xi_i}, we have that
#' \eqn{\tau_i = f(\xi_i) = c_0 + c_1 \, \xi_i}.
#' We generally do not care much about the shape of \eqn{f(\xi_i)}. We are
#' more interested in the values \eqn{\tau_i} and the shape of \eqn{g}.
#' Assuming that \eqn{g} is linear, we have that
#' 
#' \eqn{g(\tau_i) = \beta_0 + \beta_1 \cdot \tau_i + e_{i}}.
#' 
#' Thus, we simulate \eqn{(x_{ir}, y_{ir})} from:
#' 
#' \eqn{x_{ir} = \tau_i + h_{ir} \newline
#'      y_{ir} = g(\tau_i) + v_{ir}},
#' 
#' where \eqn{g} is some function.
#' 
#' If we wish to specify \eqn{f} (not very informative) we can specify it
#' through \code{c0} and \code{c1}. \eqn{g} is specified through numerous
#' parameters such as \code{b0}, \code{b1}, \code{qpos}, \code{qran},
#' \code{mmax}, \code{prop} and \code{type}. One can also specify \eqn{g}
#' using a custom R function. See explanation of \code{parameters}.
#' 
#' \eqn{\tau_i} is a random variable modelled through \code{cil}, \code{ciu},
#' \code{dist} and \code{df_tau}.
#' 
#' \eqn{h_{ir}} and \eqn{v_{ir}} are the measurement error components and
#' are modelled through \code{cvx}, \code{cvy}. The coefficients of variation,
#' \code{cvx}, \code{cvy} can be functions of \code{error_dist}, \code{dfx},
#' \code{dfy}, \code{eta} and \code{eta0}.
#' 
#' In order to convert the outputted \code{list} to a data frame structure,
#' use either \code{as.data.frame()}, \code{as.data.table()} or
#' \code{as.tibble()}.  The most efficient way to convert the output is
#' however \code{setDT()} from the \code{data.table} package.
#' 
#' Note, there is no guarantee that every simulated \eqn{(x_{ir}, y_{ir})}
#' will take positive values. To avoid negative values, you will need to
#' select values of \code{cil}, \code{ciu}, \code{cvx}, \code{cvy}, and
#' \code{mmax} that result in a negligble probability of generating negative
#' values. In general, avoid using large values of \code{cvx} and \code{cvy}
#' if \code{cil} is close to zero and \code{ciu} - \code{ciu} is large.
#' Negative values can alternatively be replaced with \code{NA} values if
#' \code{md_method = 'mnar0'}.
#'
#' @return
#' A \code{list} of length three or four:
#' \itemize{
#'   \item \code{SampleID:} An \code{integer} vector. Sample identifiers.
#'   \item \code{ReplicateID:} An \code{integer} vector. Replicate identifiers.
#'                             Only appears if \code{AR = TRUE}.
#'   \item \code{MP_A:} An \code{numeric} vector. Simulated measurements from
#'                      one of the IVD-MDs in comparison.
#'   \item \code{MP_B:} An \code{numeric} vector. Simulated measurements from
#'                      the other IVD-MD in comparison.
#' }
#'
#' @examples
#' # Load package
#' library(fasteqa)
#' 
#' # Simulate 25 clinical samples measure in triplicate affected by random
#' # differences in non-selectivity
#' 
#' parameters_cs <- list(n = 25,
#'                       R = 3,
#'                       cvx = 0.01,
#'                       cvy = 0.01,
#'                       cil = 2,
#'                       ciu = 10,
#'                       prop = 0.2,
#'                       mmax = 5)
#' simulated_cs <- sim_eqa_data(parameters_cs,
#'                              type = 0,
#'                              AR = TRUE)
#' print(as.data.frame(simulated_cs))
#' 
#' 
#' # Simulate 30 clinical samples and 3 External Quality Assessment material
#' # samples (all measured in duplicate) that are commutable with the
#' # clinical samples.
#' 
#' parameters_cs <- list(n = 30,
#'                       R = 2,
#'                       cvx = 0.01,
#'                       cvy = 0.01,
#'                       cil = 5,
#'                       ciu = 90,
#'                       qran = 0.30,
#'                       qpos = 1,
#'                       mmax = 7.5)
#'
#' simulated_cs <- sim_eqa_data(parameters_cs,
#'                              type = 0,
#'                              AR = TRUE,
#'                              include_parameters = TRUE)
#' true_values_eqa_samples <- c(10, 40, 75)                             
#' parameters_eq <- simulated_cs$parameters
#' parameters_eq <- c(list(obs_tau = true_values_eqa_samples),
#'                    parameters_eq)
#' simulated_cs <- simulated_cs$simulated_data
#' simulated_eq <- sim_eqa_data(parameters_eq,
#'                              type = 0,
#'                              AR = TRUE)
#' print(as.data.frame(simulated_cs))
#' print(as.data.frame(simulated_eq))
#'                              
#'
NULL

simulate_eqa_data <- function(parameters, silence = 1L) {
    .Call(`_fasteqa_simulate_eqa_data`, parameters, silence)
}

sim_eqa_data <- function(parameters = NULL, type = 0L, AR = FALSE, include_parameters = FALSE) {
    .Call(`_fasteqa_sim_eqa_data`, parameters, type, AR, include_parameters)
}

