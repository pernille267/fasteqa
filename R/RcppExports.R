# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Estimate bias and skewness corrected bootstrap confidence intervals
#' 
#' @title Estimate bias and skewness corrected bootstrap confidence intervals
#' @name BCa_bootstrap_ci
#' 
#' @param bootstrapped_parameter_estimates Numeric vector - Bootstrapped estimates of the parameter of interest
#' @param jackknife_parameter_estimates Numeric vector - Jack knife estimates of the parameter of interest
#' @param original_parameter_estimate Double - Original point estimate of the parameter of interest
#' @param level Double - Required confidence level for the estimated confidence interval
#' @param silence Integer - Controls the progress reports outputted for debugging and further examination of the command. \code{silence = -1} or \code{silence = 0} signify that progress reports should be printed. Default is \code{silence = 1} which suppresses all printing
#'
#' @description Estimation of bootstrap confidence intervals for a parameter of interest using the BCa-variant
#'
#' @details To get an adequate estimate of the theoretical confidence interval, it is essential that original data represents the underlying distribution for the population parameter. More data typically corresponds with larger probability of our data being representative. For bootstrap confidence interval estimation independent of jack knife estimates, \code{bootstrap_ci()} may be used instead
#'
#' @return A numeric vector. The first element of the vector is the lower bound of the confidence interval, and the second element of the vector is the upper bound of the confidence interval 
#'
#' @examples \dontrun{
#'   fictional_original_estimate <- 2.1
#'   fictional_bootstrap_estimates <- runif(n = 1e3, min = 0.5, max = 2.5)
#'   fictional_jackknife_estimates <- runif(n = 1e1, min = 1.5, max = 2.5)
#'   BCa_bootstrap_ci(fictional_bootstrap_estimates,
#'                    fictional_jackknife_estimates,
#'                    fictional_original_estimate,
#'                    level = 0.95,
#'                    silence = 1)
#' }
NULL

BCa_bootstrap_ci <- function(bootstrapped_parameter_estimates, jackknife_parameter_estimates, original_parameter_estimate = 0, level = 0.95, silence = 1L) {
    .Call(`_fasteqa_BCa_bootstrap_ci`, bootstrapped_parameter_estimates, jackknife_parameter_estimates, original_parameter_estimate, level, silence)
}

#' Estimate relative non-selectivity measure k based on data
#' 
#' @title Estimate MS precision measures
#' @name Estimatek
#' @param data A data table or a data frame converted to a list so that each column is a unique list element. The ID columns must be of character type and contain SampleID, ReplicateID, MP_A and MP_B 
#' @param silence An integer (-1, 0, 1) that controls how much is printed. 0 shows some messages regarding temporary output, whereas -1 shows even more messages for debugging. -1 is used for superusers.
#' 
#' @description Estimate the relative non-selectivity measure k, that is the ratio of the pooled prediction error variance and the sum of repeatability variances.  
#' 
#' @details Differences in non-selectivity between measurement systems may cause problems in e.g., evaluation of commutability. A large value of k indicate that we have have large differences in selectivity
#' 
#' @return A single estimate of k (in a list) based on the specific grouped data. The k values are float values meaning that the precision is 1e-6 (six decimals precision). This is considered enough for us
#'
#' @examples \dontrun{
#'   print("Estimate k")
#' }
#'
NULL

Estimatek <- function(data, silence = 1L) {
    .Call(`_fasteqa_Estimatek`, data, silence)
}

#' Estimate pointwise prediction intervals based on Deming regression
#'
#' @title Estimation of prediction intervals or prediction band based on Deming regression
#' @name PredictDeming
#' 
#' @param data A data table or data frame converted to a list so that each column is a unique list element. Must contain the following columns: MP_A and MP_B
#' @param NewData A numeric vector of which x values are used to predict y
#' @param Precision A list of the Precision estimates based on \code{CharacterEstimatePrecision()}
#' @param MaxR The number of replicates for the majority of clinical samples. For example, if 18 of 25 CSs are meausured in triplicate, and the remaining seven is measured in duplicate, we use \code{MaxR = 3}
#' @param level the confidence level of the pointwise prediction intervals constructed. If the prediction intervals are used to evaluate commutability of EQAMs, you must remember to adjusts for simultanuous testing, e.g., Bonferroni correction
#' @param type which type of estimation approach should be used to construct the pointwise prediction intervals? \code{type = 0} correspond to J. Gillard and W. Fullers' approach. \code{type = 1} corresponds to CLSI's approach (elaborated upon in EP14). The first-mentioned is the default choice
#' @param rounding how many decimal places should be use in the estimates? Default is 3
#' @param Should estimated true concentration levels be part of the output? Default is 0 which signify no. This will only return something if \code{type = 0}
#' @param silence an integer that controls progress reports. Set to 0 for these progress reports to appear. For additional debugging information, set this to \code{-1}. Default is \code{1}, which means that only the output will be returned, and no messages
#' 
#' @description Estimation of prediction intervals based on the Deming model is relevant in e.g., commutability evaluation of EQAMs. 
#' 
#' @return A list with four elements, which are, nx (inputted new data), fit (predicted y values based on new data), lwr (lower prediction interval bound), upr (upper prediction interval bound). Use \code{setDT()} from data.table to merge the list elements into a data table
#'
NULL

PredictDeming <- function(data, NewData, Precision, MaxR, level = 0.99, type = 0L, rounding = 3L, CalculateLatent = 0L, silence = 1L) {
    .Call(`_fasteqa_PredictDeming`, data, NewData, Precision, MaxR, level, type, rounding, CalculateLatent, silence)
}

#' Estimate pointwise prediction intervals based on OLS regression
#'
#' @title Estimation of prediction intervals or prediction band based on OLS regression
#' @name PredictOLS
#' 
#' @param data A data table or data frame converted to a list so that each column is a unique list element. Must contain the following columns: MP_A and MP_B
#' @param NewData A numeric vector of which x values are used to predict y
#' @param Precision A list of the Precision estimates based on \code{CharacterEstimatePrecision()}
#' @param MaxR The number of replicates for the majority of clinical samples. For example, if 18 of 25 CSs are meausured in triplicate, and the remaining seven is measured in duplicate, we use MaxR = 3
#' @param level the confidence level of the pointwise prediction intervals constructed. If the prediction intervals are used to evaluate commutability of EQAMs, you must remember to adjusts for simultanuous testing, e.g., Bonferroni correction
#' @param silence an integer that controls progress reports. Set to 0 for these progress reports to appear. For additional debugging information, set this to \code{-1}. Default is \code{1}, which means that only the output will be returned, and no messages
#' 
#' @description Estimation of prediction intervals based on the OLS regression model is relevant in e.g., commutability evaluation of EQAMs
#' 
#' @return A list with four elements, which are, nx (inputted new data), fit (predicted y values based on new data), lwr (lower prediction interval bound), upr (upper prediction interval bound). Use \code{setDT()} from data.table to merge the list elements into a data table
NULL

PredictOLS <- function(data, NewData, Precision, MaxR, level, silence = 1L) {
    .Call(`_fasteqa_PredictOLS`, data, NewData, Precision, MaxR, level, silence)
}

#' Estimate simple bootstrap confidence intervals
#' 
#' @title Estimate simple bootstrap confidence intervals
#' @name bootstrap_ci
#' 
#' @param bootstrapped_parameter_estimates Numeric vector - Bootstrapped estimates of the parameter of interest
#' @param original_parameter_estimate Double - Original point estimate of the parameter of interest
#' @param type Integer - Which type of bootstrap confidence interval is required
#' \itemize{
#'   \item{\code{1: }}{Standard normal bootstrap confidence interval}
#'   \item{\code{2: }}{Basic bootstrap confidence interval}
#'   \item{\code{3: }}{Percentile bootstrap confidence interval}
#' }
#' @param level Double - Required confidence level for the estimated confidence interval
#' @param silence Integer - Controls the progress reports outputted for debugging and further examination of the command. \code{silence = -1} or \code{silence = 0} signify that progress reports should be printed. Default is \code{silence = 1} which suppresses all printing
#'
#' @description Estimation of bootstrap confidence intervals for a parameter of interest
#'
#' @details To get an adequate estimate of the theoretical confidence interval, it is essential that original data represents the underlying distribution for the population parameter. More data typically corresponds with larger probability of our data being representative. For second-order accurate and transformation respective confidence intervals, you may employ \code{BCa_bootstrap_ci()} instead. Note that \code{BCa_bootstrap_ci()} require jack knife estimates of the parameter of interest as well as bootstrap estimates 
#'
#' @return A numeric vector. The first element of the vector is the lower bound of the confidence interval, and the second element of the vector is the upper bound of the confidence interval 
#'
#' @examples \dontrun{
#'   fictional_original_estimate <- 2.1
#'   fictional_bootstrap_estimates <- runif(n = 1e3, min = 0.5, max = 2.5)
#'   bootstrap_ci(fictional_bootstrap_estimates,
#'                fictional_original_estimate,
#'                type = 3,
#'                level = 0.95,
#'                silence = 1)
#' }
NULL

bootstrap_ci <- function(bootstrapped_parameter_estimates, original_parameter_estimate = 0, type = 3L, level = 0.95, silence = 1L) {
    .Call(`_fasteqa_bootstrap_ci`, bootstrapped_parameter_estimates, original_parameter_estimate, type, level, silence)
}

#' Apply a mathematical summary function on every SampleID
#' 
#' @title Apply a mathematical summary function on every SampleID
#' @name fun_of_replicates
#' 
#' @param data \code{list} or \code{data table} - Data with elements/columns \code{SampleID}, \code{ReplicateID}, \code{MP_A} and \code{MP_B}
#' @param fun \code{string} - Used to choose the summary function one want to apply on each samples' measurements. Here is the list of possible valid summary functions:
#' \itemize{
#'   \item{\code{mean: }}{Taking the average of replicated measurments for samples with at least one measurement. Default}
#'   \item{\code{median: }}{Taking the median of replicated measurments for samples with at least one measurement}
#'   \item{\code{min: }}{Taking the minimum of replicated measurments for samples with at least one measurement}
#'   \item{\code{max: }}{Taking the maximum of replicated measurements for samples with at least one measurement}
#'   \item{\code{var: }}{Taking the variance of replicated measurements for samples with at least two measurements}
#'   \item{\code{sd: }}{Taking the standard deviation of replicated measurements for samples with at least two measurements}
#'   \item{\code{cv: }}{Taking the coefficient of variation of replicated measurements for samples with at least two measurements}
#' }
#' @param silence \code{integer} - Should debugging messages be printed. Default is no
#'
#' @description A practical function to evaluate summary typical summary functions of samples' replicated measurements. Taking mean of replicates, sd of replicates or cv of replicates are typical when analyzing EQA data so these are very useful. The remaning functions are not used as much, but may be needed in some cases so they are included based on this fact. In order for this function to work propery you need to ensure that:
#' \itemize{
#'   \item{\code{SampleID: }}{Must be a character vector}
#'   \item{\code{ReplicateID: }}{Must be a character vector}
#'   \item{\code{MP_A: }}{Must be a numeric vector}
#'   \item{\code{MP_B: }}{Must be a numeric vector}
#' }
#'
#' @details The difference between this function and \code{mean_of_replicates()} method in the \code{commutability.selectivity}, is that this is more than ten times faster.
#'
#' @return list - data containing the elements that is needed to build the resulting data of results. Use \code{setDT()} for maximum efficiency when converting the list into a data table 
#'
#' @examples \dontrun{
#'   library(fasteqa)
#'   data <- simulate_eqa_data()
#'   mean_of_replicates_data <- fun_of_replicates(data)
#'   var_of_replicates_data <- fun_of_replicates(data, "var")
#' }
NULL

fun_of_replicates <- function(data, fun = "mean", silence = 1L) {
    .Call(`_fasteqa_fun_of_replicates`, data, fun, silence)
}

#' Calculate imprecision point estimates of measurements in a given MS comparison 
#' 
#' @title Calculate imprecision point estimates of measurements in a given MS comparison
#' @name global_precision_estimates
#' 
#' @param data \code{list} or \code{data table} - Data with elements/columns \code{SampleID}, \code{ReplicateID}, \code{MP_A} and \code{MP_B}
#' @param silence \code{integer} - Should debugging messages be printed. Default is no
#'
#' @description Structure-requirement of \code{data}:
#' \itemize{
#'   \item{\code{SampleID: }}{Must be a character vector}
#'   \item{\code{ReplicateID: }}{Must be a character vector}
#'   \item{\code{MP_A: }}{Must be a numeric vector}
#'   \item{\code{MP_B: }}{Must be a numeric vector}
#' }
#'
#' @details Calculates various global imprecision estimates. To get CVs in percent you need only to multiply the raw CV estimates with 100. Here is a rough explaination of the output list:
#' \itemize{
#'   \item{\code{Var_A: }}{Pooled variance of all sample-variances based on MS_A}
#'   \item{\code{Var_B: }}{Pooled variance of all sample-variances based on MS_B}
#'   \item{\code{CV_A: }}{Global CV estimate based on Var_A and the grand mean of all measurements from MS_A}
#'   \item{\code{CV_B: }}{Global CV estimate based on Var_B and the grand mean of all measurements from MS_B}
#'   \item{\code{lambda: }}{Ratio of pooled variances Var_A and Var_B}
#' }
#' 
#'
#' @return \code{list} - with point imprecision estimates \code{Var_A}, \code{Var_B}, \code{CV_A}, \code{CV_B} and \code{lambda}
#' @examples \dontrun{
#'   library(fasteqa)
#'   data <- simulate_eqa_data(list(n = 25, R = 3, cvx = 0.02, cvy = 0.3))
#'   data$SampleID <- as.character(data$SampleID)
#'   data$ReplicateID <- as.character(data$ReplicateID)
#'   global_prcision_estimates(data = data)
#' }
NULL

global_precision_estimates <- function(data, silence = 1L) {
    .Call(`_fasteqa_global_precision_estimates`, data, silence)
}

#' Leave-one-out on clustered EQA clinical sample data
#' 
#' @title Leave-one-out on clustered EQA clinical sample data
#' @name leave_one_out
#' 
#' @param data \code{List} or \code{data table} - Data with list elements or data table columns with names \code{SampleID}, \code{ReplicateID}, \code{MP_A} and \code{MP_B}. \code{SampleID} and \code{ReplicateID} must be of character type for the function to operate correctly
#' @param loo_id Integer - Which of the samples of \code{SampleID} should be left out. Default value is 1
#'
#' @description Needed to calculate jack knife estimates of a parameter, that is required when using \code{BCa_bootstrap_ci()}. Alternatively one could use the Jack knife estimates to calculate standard error or bias of the estimator of relevance
#'
#' @details loo_ids can not be vectorized directly in R. Use \code{sapply()} or \code{replicate()} to leave out sample IDs one by one 
#'
#' @return A \code{list} containing the original data, but without the sample id corresponding to the given \code{loo_id} 
#'
#' @examples \dontrun{
#'   library(commutability.selectivity)
#'   data <- sdwdnsp2()
#'   loo_data <- leave_one_out(data, loo_id = 5)
#' }
NULL

leave_one_out <- function(data, loo_id = 1L) {
    .Call(`_fasteqa_leave_one_out`, data, loo_id)
}

#' Estimate prediction intervals for EQA data with Deming or OLS
#' 
#' @title Estimate prediction intervals for EQA data with Deming or OLS
#' @name predict_eqa
#' 
#' @param data \code{list} or \code{data table} - Mean-of-replicates clinical sample data with elements/columns \code{SampleID}, \code{MP_A} and \code{MP_B}
#' @param new_data \code{list} or \code{data table} - Mean-of-replicates control material data with \code{MP_B}. \code{SampleID} and \code{MP_A} may also be in new_data based on desired output structure:
#' \itemize{
#'   \item{\code{Minimum requirement: }}{Must contain \code{MP_B}}
#'   \item{\code{method = ols: }}{Must at least contain both \code{MP_B} and \code{MP_A}}
#'   \item{\code{Inside checks performed: }}{Must at least contain both \code{MP_B} and \code{MP_A}}
#'   \item{\code{Sample-wise prediction}}{Must at least contain \code{MP_B} and \code{SampleID} (plus \code{MP_A} if method = ols)}
#' }
#' @param imprecision_estimates \code{list} or \code{data table} - Imprecision estimates e.g., that which are outputted by \code{global_precision_estimates()}. Minimum requirement: \code{lambda} and \code{Var_B} must be part of the  
#' @param R integer - Number of replicates, which new_data is based on
#' @param method string - Which method should be used to estimate the prediction intervals. Default is \code{fg}. At the moment, possible values for method is
#' \itemize{
#'   \item{\code{fg: }}{Standard Deming regression, but prediction intervals are calculated using components from J. Gillards work}
#'   \item{\code{clsi: }}{Standard Deming regression, but prediction intervals are calculated based on derivation of Jeff Vaks}
#'   \item{\code{ols: }}{Ordinary least squares regression, but the predictor is chosen so that neglected prediction error variance is reduced}
#' }
#' @param level float - Confidence level of prediction intervals. Should ideally be corrected for simulations testing. Default level is 0.99
#' @param rounding integer - How many decimals should be included in the predictions and prediction intervals. Two or three decimals are often sufficient. Default is 3
#'
#' @description A rich function that calculates prediction intervals for EQA data
#' 
#'
#' @details If possible it is wise to always include \code{SampleID}, \code{MP_A} and \code{MP_B} in new_data. If by some reason only \code{MP_B} is available, one cannot use \code{method = ols}. For example, when construction predicton bands, we will only have \code{MP_B} is available.
#'
#' @return list - prediction interval data based on use-inputs
#'
#' @examples \dontrun{
#'   library(fasteqa)
#'   training_parameters <- list(n = 25, R = 3, cvx = 0.01, cvy = 0.015, cil = 10, ciu = 70)
#'   test_parameters <- list(n = 5, R = 3, cvx = 0.01, cvy = 0.015, cil = 10, ciu = 70)
#'   training_data <- simulate_eqa_data(training_parameters)
#'   test_data <- simulate_eqa_data(test_parameters)
#'   training_data$$SampleID <- as.character(training_data$SampleID)
#'   training_data$$ReplicateID <- as.character(training_data$ReplicateID)
#'   imprecision <- global_precision_estimates(data)
#'   mean_of_replicates_training_data <- fun_of_replicates(training_data)
#'   mean_of_replicates_test_data <- fun_of_replicates(test_data)
#'   prediction_intervals <- predict_eqa(mean_of_replicates_training data,
#'                                       mean_of_replicates_test_data,
#'                                       imprecision)
#' }
NULL

predict_eqa <- function(data, new_data, imprecision_estimates, R = 3L, method = "fg", level = 0.99, rounding = 3L) {
    .Call(`_fasteqa_predict_eqa`, data, new_data, imprecision_estimates, R, method, level, rounding)
}

#' Resample clustered EQA clinical sample data
#' 
#' @title Resample clustered EQA clinical sample data
#' @name resample_samples
#' 
#' @param data A list or a data table with elements/columns \code{SampleID}, \code{ReplicateID}, \code{MP_A} and \code{MP_B}. \code{SampleID} and \code{ReplicateID} must be of character type for the function to operate correctly
#' @param silence An integer that controls the progress reports outputted for debugging and further examination of the command. \code{silence = -1} or \code{silence = 0} signify that progress reports should be printed. Default is \code{silence = 1} which suppresses all printing
#'
#' @description In order to construct bootstrap confidence intervals and do inference on a set of population parameters where the underlying distribution is complex, will require resample of clustered data. This function is both efficient and does its job, but at a cost of a strict input requirement
#'
#' @details \code{resample_samples()} is a very efficient algorithm to resample EQA. Combine with \code{Estimatek()} to resample k or combine with \code{CharacterEstimatePrecision()} to resample variability measures such as CVs and variances. May also be combined with other functions
#'
#' @return A list containing the resampled EQA clinical sample data. Use \code{setDT()} for maximum efficiency if needed to convert the resampled data to a data table
#'
#' @examples \dontrun{
#'   library(commutability.selectivity)
#'   data <- sdwdnsp2()
#'   data$SampleID <- as.character(data$SampleID)
#'   data$ReplicateID <- as.character(data$ReplicateID)
#'   resampled_data <- resample_samples(data)
#' }
NULL

resample_samples <- function(data, silence = 1L) {
    .Call(`_fasteqa_resample_samples`, data, silence)
}

#' Simulation of EQA data based on study design and potential differences in non-selectivity
#'
#' @title Simulation of EQA data based on study design and potential differences in non-selectivity
#' @name simulate_eqa_data
#' 
#' @param parameters A \code{list} of parameters used to simulate the EQA data. You must at least specify one parameter for this function to run. Except that one mandatory parameter, you may optionally choose the remaining of the parameters. These are the optimal parameters that you may include into the list:
#' \itemize{
#'   \item{\code{n: }}{  The number of clinical samples}
#'   \item{\code{R: }}{The number of replicates on each sample}
#'   \item{\code{cvx: }}{The analytical CV of x measurements}
#'   \item{\code{cvy: }}{The analytical CV of y measurements}
#'   \item{\code{cil: }}{The lower range of the concentration interval}
#'   \item{\code{ciu: }}{The upper range of the concentration interval}
#'   \item{\code{qpos: }}{Position of systematic differences in non-selectivity. 0 signify lower range and 1 signify upper range}
#'   \item{\code{qran: }}{Interquantile range where systematic differences in non-selectivity should have its effect}
#'   \item{\code{prop: }}{average proportion of clinical samples affected by random differences in non-selectivity}
#'   \item{\code{mmax: }}{The maximum relocation magnitude in number of analytical SDs of y measurements. This assumes either prop or qpos and qran to be specified as well}
#' }
#' @param silence \code{Integer} should temporary calculation results be printed? This may be useful for debugging or strange curiosity. \code{silence = 1} signify that printing will be suppressed, which is the default. \code{silence = 0} allows such printing 
#' 
#' @description Simulates a data set with n x R rows, and four columns. The two first columns are the base ID columns (\code{SampleID} and \code{ReplicateID}). The remaining columns are numeric columns holding measurement results from the two MSs in comparison (MS_A and MS_B) denoted \code{MP_A} and \code{MP_B}.
#' @details In order to convert the outputted list to a table, use either \code{as.data.frame()}, \code{as.data.table()}, \code{as.tibble()}. The most efficient way to convert is \code{setDT()} from the \code{data.table} package.
#'
#' @return A list where each list element is a column of the generated EQA data
#'
#' @examples \dontrun{
#'   simulated_data <- simulate_eqa_data(parameters = list(n = 25, R = 3, prop = 0.1, mmax = 5))
#'   simulated_data <- setDT(simulated_data)
#' }
#'
NULL

simulate_eqa_data <- function(parameters, silence = 1L) {
    .Call(`_fasteqa_simulate_eqa_data`, parameters, silence)
}

