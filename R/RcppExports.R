# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Estimate bias and skewness corrected bootstrap confidence intervals
#' 
#' @title Estimate bias and skewness corrected bootstrap confidence intervals
#' @name BCa_bootstrap_ci
#' 
#' @param bootstrapped_parameter_estimates A \code{numeric vector} storing bootstrapped estimates of the target parameter. A couple of missing values are allowed and will be removed if present.
#' @param jackknife_parameter_estimates A \code{numeric vector} containing Jackknife estimates of the target parameter. A couple of missing values are allowed and will be removed if present.
#' @param original_parameter_estimate A \code{double} representing the original point estimate of the target parameter. A missing value is not allowed.
#' @param level A \code{double} between 0 and 1, indicating the desired confidence level for the estimated BCa bootstrap confidence interval of the target parameter. Defaulting to \code{0.95}.
#' @param silence An \code{integer} controlling the level of progress reporting for debugging and analysis. Set to \code{-1} or \code{0} for detailed reports. Defaults to \code{1} to suppress output.
#'
#' @description This function estimates the bootstrap confidence intervals for a specified parameter using a Bias-Correction and Acceleration (BCa) approach. It requires precomputed Jackknife (leave-one-out) estimates of the parameter of interest. These can be generated by iterating over all unique SampleIDs in your dataset and employing the \code{leave_one_out()} function from this package for each unique ID.
#'
#' @details To accurately estimate the theoretical confidence interval for the parameter of interest, the original dataset must adequately represent the underlying distribution of the population parameter. Typically, larger datasets increase the likelihood of representativeness. To compute bootstrap confidence intervals independent of Jackknife estimates, consider using the \code{bootstrap_ci()} function instead.
#'
#' @return A \code{numeric vector} with two entries: the lower and upper bounds of the BCa bootstrap confidence interval, respectively.  
#'
#' @examples \dontrun{
#'   fictional_original_estimate <- 2.1
#'   fictional_bootstrap_estimates <- runif(n = 1e3, min = 0.5, max = 2.5)
#'   fictional_jackknife_estimates <- runif(n = 1e1, min = 1.5, max = 2.5)
#'   BCa_bootstrap_ci(fictional_bootstrap_estimates,
#'                    fictional_jackknife_estimates,
#'                    fictional_original_estimate,
#'                    level = 0.95,
#'                    silence = 1)
#' }
NULL

BCa_bootstrap_ci <- function(bootstrapped_parameter_estimates, jackknife_parameter_estimates, original_parameter_estimate = 0, level = 0.95, silence = 1L) {
    .Call(`_fasteqa_BCa_bootstrap_ci`, bootstrapped_parameter_estimates, jackknife_parameter_estimates, original_parameter_estimate, level, silence)
}

#' Estimate simple bootstrap confidence intervals
#' 
#' @title Estimate simple bootstrap confidence intervals
#' @name bootstrap_ci
#' 
#' @param bootstrapped_parameter_estimates A \code{numeric vector} storing bootstrapped estimates of the target parameter. A couple of missing values are allowed and will be removed if present.
#' @param original_parameter_estimate A \code{double} representing the original point estimate of the target parameter. A missing value is not allowed.
#' @param type An \code{integer} that refers to the type of bootstrap confidence interval to be estimated. Valid inputs include:
#' \itemize{
#'   \item{\code{1: }}{Standard normal bootstrap confidence interval}
#'   \item{\code{2: }}{Basic bootstrap confidence interval}
#'   \item{\code{3: }}{Percentile bootstrap confidence interval}
#' }
#' @param level A \code{double} between 0 and 1, indicating the desired confidence level for the estimated bootstrap confidence interval of the target parameter. Defaulting to \code{0.95}.
#' @param silence An \code{integer} controlling the level of progress reporting for debugging and analysis. Set to \code{-1} or \code{0} for detailed reports. Defaults to \code{1} to suppress output.
#'
#' @description Estimation of bootstrap confidence intervals for a parameter of interest based on \code{bootstrapped_parameter_estimates}, \code{original_parameter_estimate}, \code{type} and \code{level}. 
#'
#' @details To get an adequate estimate of the theoretical confidence interval for the target parameter, it is essential that the original data represents the underlying distribution for the population parameter. More data typically corresponds with larger probability of our data being representative. For second-order accurate and transformation respective confidence intervals, you may employ \code{BCa_bootstrap_ci()} instead. Note that \code{BCa_bootstrap_ci()} requires jack knife estimates of the parameter of interest as well as bootstrap estimates 
#'
#' @return A \code{numeric vector} with two entries: the lower and upper bounds of the bootstrap confidence interval, respectively.
#'
#' @examples \dontrun{
#'   fictional_original_estimate <- 2.1
#'   fictional_bootstrap_estimates <- runif(n = 1e3, min = 0.5, max = 2.5)
#'   bootstrap_ci(fictional_bootstrap_estimates,
#'                fictional_original_estimate,
#'                type = 3,
#'                level = 0.95,
#'                silence = 1)
#' }
NULL

bootstrap_ci <- function(bootstrapped_parameter_estimates, original_parameter_estimate = 0, type = 3L, level = 0.95, silence = 1L) {
    .Call(`_fasteqa_bootstrap_ci`, bootstrapped_parameter_estimates, original_parameter_estimate, type, level, silence)
}

#' Count the number of replicated measurements for each sample for either CS data or EQAM data
#'
#' @title Count the number of replicated measurements for each sample for either CS data or EQAM data
#' @name count_samplewise_replicates
#'
#' @description This function counts the number of replicated measurements done on each sample within a IVD-MD comparison for either clinical sample (CS) data or external quality asessment material (EQAM) data 
#'
#' @param data A \code{list} or \code{data.table} representing CS data or EQAM data with the \code{list} elements or \code{data.table} columns: \code{SampleID}, \code{MP_A}, and \code{MP_B}.
#' @param summary A \code{character} specifying the summary statistic of the sample-wise number of replicates. Default is \code{'mode'}. Possible summary statistics include:
#' \itemize{
#'   \item{\code{none}: }{Returns a \code{integer vector} containing the sample-wise number of replicates for the input \code{data}.}
#'   \item{\code{mode}: }{Returns the mode of the sample-wise number of replicates for the input \code{data}.}
#'   \item{\code{median}: }{Returns the median of the sample-wise number of replicates for the input \code{data}.}
#'   \item{\code{mean}: }{Returns the arithmetic mean (\code{float} type) calculated from the sample-wise number of replicates present in the input \code{data}.}
#'   \item{\code{ceiling}: }{Computes and returns the rounded-up (ceiling) value of the arithmetic mean calculated from the sample-wise number of replicates present in the input \code{data}.}
#'   \item{\code{floor}: }{Computes and returns the rounded-down (floor) value of the arithmetic mean calculated from the sample-wise number of replicates present in the input \code{data}.}
#'   \item{\code{round}: }{Computes and returns the rounded (nearest integer) value of the arithmetic mean calculated from the sample-wise number of replicates present in the input \code{data}.}
#' }
#' @param invalid_NA A \code{logical} that determines the function's behavior in response to invalid \code{data} or \code{summary} input. If set to TRUE, the function will return an NA value when encountering invalid input or computation errors, rather than throwing an error. While generally not recommended due to potential masking of issues, this may be useful in certain scenarios where uninterrupted execution is desired.
#' @param silence An \code{integer} that dictates the verbosity level of the console output. If \code{silence} is set to a value less than 1, various verbose output, including debugging reports, will be displayed depending on the specific value of \code{silence}.
#'
#' @details The function \code{predict_eqa()} hinges on the count of replicates performed for its \code{data} parameter. When the \code{method} is either 'fg' or 'ols', it's essential to tally the replicates for both \code{data} and \code{new_data} inputs. This handy function offers a streamlined solution. It allows for the direct usage of \code{predict_eqa()} without requiring manual counting of the sample-wise replicates, thereby enhancing efficiency and ease of use.
#'
#' @return Returns a \code{list} that contains a single element, \code{R_i}. The type of \code{R_i} depends on the value of the \code{summary} parameter. It is typically an integer. However, if \code{summary} is set to 'none', \code{R_i} becomes an integer vector. When \code{summary} is set to 'mean', \code{R_i} is returned as a floating-point number.
#'
#' @examples \dontrun{
#' library(fasteqa)
#' # Simulation parameters for clinical sample data
#' cs_parameters <- list(n = 25, R = 3,
#'                       cvx = 0.01, cvy = 0.015,
#'                       cil = 10, ciu = 70)
#' # Use the simulation parameters to simulate toy clinical sample data                      
#' cs_data <- simulate_eqa_data(cs_parameters)
#' # Calculate mode of sample-wise number of replicates
#' mode_R <- count_samplewise_replicates(cs_data, summary = 'mode')$R_i
#' # Count sample-wise number of replicates
#' samplewise_R <- count_samplewise_replicates(cs_data, summary = 'none')$R_i                                    
#' }
NULL

count_samplewise_replicates <- function(data, summary = "mode", invalid_NA = TRUE, silence = 1L) {
    .Call(`_fasteqa_count_samplewise_replicates`, data, summary, invalid_NA, silence)
}

#' Calculate Absolute Differences in Non-Selectivity
#'
#' @title Calculate Absolute Differences in Non-Selectivity
#' @name estimate_absolute_dins
#' @param data \code{list} or \code{data.table} - The input dataset that must contain the following columns: \code{SampleID}, \code{ReplicateID}, \code{MP_A}, and \code{MP_B}.
#' @param silence \code{integer} - The verbosity level of the output. Be aware that excessive progress reporting might negatively impact performance. The valid input options are as follows:
#' \itemize{
#' \item{\code{1: }}{All progress reports are silenced (default setting)}
#' \item{\code{0: }}{Progress reports are partially shown, while debugging reports are omitted}
#' \item{\code{-1: }}{All progress reports are enabled, providing the most detailed output}
#' }
#'
#' @description This function calculates the absolute value of differences in non-selectivity, which are crucial when evaluating the commutability of reference materials or external quality assessment materials in the context of in vitro diagnostic medical devices.
#'
#' @details Differences in non-selectivity between diagnostic devices may lead to difficulties in commutability assessments. Larger values of absolute differences are particularly problematic. The function provides a point estimate of these differences with a precision of 1e-6.
#'
#' @return A list containing the point estimate of the absolute magnitude of differences in non-selectivity with a precision of 1e-6.
#'
#' @examples \dontrun{
#' library(fasteqa)
#' data <- simulate_data_eqa(list(n = 25, R = 3, cvx = 0.06, cvy = 0.04))
#' calculate_absolute_dins(data)
#' }
NULL

estimate_absolute_dins <- function(data, silence = 1L) {
    .Call(`_fasteqa_estimate_absolute_dins`, data, silence)
}

#' Estimate differences in non-selectivity with zeta
#' 
#' @title Estimate differences in non-selectivity with zeta
#' @name estimate_zeta
#' @param data \code{list} or \code{data table} - Data with elements/columns \code{SampleID}, \code{ReplicateID}, \code{MP_A} and \code{MP_B}
#' @param silence \code{integer} - How much progress reports should be returned. Note that returning progress reports will slow down the performance drastically. There are three valid inputs:
#' \itemize{
#'   \item{\code{1: }}{All progress reports are silenced and is the default}
#'   \item{\code{0: }}{Some progress reports are delivered, but debugging reports are suppressed}
#'   \item{\code{-1: }}{All prorgress reports are delivered}
#' }
#' 
#' @description Estimate the degree of differences in non-selectivity with zeta. Zeta is is the ratio of the pooled average prediction error variance and the sum of analytical variances.  
#' 
#' @details Differences in non-selectivity between measurement systems may cause problems in e.g., evaluation of commutability. A large value of zeta indicates that we have have large differences in non-selectivity between compared measurement systems. An upper limit of acceptable zeta may be determined based on the allowable increase in prediction interval width and analyte of relevance
#' 
#' @return A list with the point estimate of zeta. The zeta value is a float value, meaning that the precision is 1e-6 (six decimals precision).
#'
#' @examples \dontrun{
#'   library(fasteqa)
#'   data <- simulate_data_eqa(list(n = 25, R = 3, cvx = 0.06, cvy = 0.04))
#'   estimate_zeta(data)
#' }
#'
NULL

estimate_zeta <- function(data, silence = 1L) {
    .Call(`_fasteqa_estimate_zeta`, data, silence)
}

#' Estimate differences in non-selectivity with zeta using Deming regression
#' 
#' @title Estimate differences in non-selectivity with zeta using Deming regression
#' @name estimate_zeta_deming
#' @param data \code{list} or \code{data table} - Data with elements/columns \code{SampleID}, \code{ReplicateID}, \code{MP_A} and \code{MP_B}
#' @param silence \code{integer} - How much progress reports should be returned. Note that returning progress reports will slow down the performance drastically. There are three valid inputs:
#' \itemize{
#'   \item{\code{1: }}{All progress reports are silenced and is the default}
#'   \item{\code{0: }}{Some progress reports are delivered, but debugging reports are suppressed}
#'   \item{\code{-1: }}{All prorgress reports are delivered}
#' }
#' 
#' @description Estimate the degree of differences in non-selectivity with zeta. Zeta is is the ratio of the pooled average prediction error variance and the sum of analytical variances.  
#' 
#' @details Differences in non-selectivity between measurement systems may cause problems in e.g., evaluation of commutability. A large value of zeta indicates that we have have large differences in non-selectivity between compared measurement systems. An upper limit of acceptable zeta may be determined based on the allowable increase in prediction interval width and analyte of relevance
#' 
#' @return A list with the point estimate of zeta. The zeta value is a float value, meaning that the precision is 1e-6 (six decimals precision).
#'
#' @examples \dontrun{
#'   library(fasteqa)
#'   data <- simulate_data_eqa(list(n = 25, R = 3, qran = 0.20, qpos = 1, mmax = 8))
#'   estimate_zeta_deming(data)
#' }
NULL

estimate_zeta_deming <- function(data, silence = 1L) {
    .Call(`_fasteqa_estimate_zeta_deming`, data, silence)
}

#' Apply a mathematical summary function on every SampleID
#' 
#' @title Apply a mathematical summary function on every SampleID
#' @name fun_of_replicates
#' 
#' @param data \code{list} or \code{data table} - Data with elements/columns \code{SampleID}, \code{ReplicateID}, \code{MP_A} and \code{MP_B}
#' @param fun \code{string} - Used to choose the summary function one want to apply on each samples' measurements. Here is the list of possible valid summary functions:
#' \itemize{
#'   \item{\code{mean: }}{Taking the average of replicated measurments for samples with at least one measurement. Default}
#'   \item{\code{median: }}{Taking the median of replicated measurments for samples with at least one measurement}
#'   \item{\code{min: }}{Taking the minimum of replicated measurments for samples with at least one measurement}
#'   \item{\code{max: }}{Taking the maximum of replicated measurements for samples with at least one measurement}
#'   \item{\code{var: }}{Taking the variance of replicated measurements for samples with at least two measurements}
#'   \item{\code{sd: }}{Taking the standard deviation of replicated measurements for samples with at least two measurements}
#'   \item{\code{cv: }}{Taking the coefficient of variation of replicated measurements for samples with at least two measurements}
#' }
#' @param silence \code{integer} - Should debugging messages be printed. Default is no
#'
#' @description A practical function to evaluate summary typical summary functions of samples' replicated measurements. Taking mean of replicates, sd of replicates or cv of replicates are typical when analyzing EQA data so these are very useful. The remaning functions are not used as much, but may be needed in some cases so they are included based on this fact. In order for this function to work propery you need to ensure that:
#' \itemize{
#'   \item{\code{SampleID: }}{Must be a character vector}
#'   \item{\code{ReplicateID: }}{Must be a character vector}
#'   \item{\code{MP_A: }}{Must be a numeric vector}
#'   \item{\code{MP_B: }}{Must be a numeric vector}
#' }
#'
#' @details The difference between this function and \code{mean_of_replicates()} method in the \code{commutability.selectivity}, is that this is more than ten times faster.
#'
#' @return list - data containing the elements that is needed to build the resulting data of results. Use \code{setDT()} for maximum efficiency when converting the list into a data table 
#'
#' @examples \dontrun{
#'   library(fasteqa)
#'   data <- simulate_eqa_data()
#'   mean_of_replicates_data <- fun_of_replicates(data)
#'   var_of_replicates_data <- fun_of_replicates(data, "var")
#' }
NULL

fun_of_replicates <- function(data, fun = "mean", silence = 1L) {
    .Call(`_fasteqa_fun_of_replicates`, data, fun, silence)
}

#' Calculate imprecision point estimates of measurements in a given MS comparison 
#' 
#' @title Calculate imprecision point estimates of measurements in a given MS comparison
#' @name global_precision_estimates
#' 
#' @param data \code{list} or \code{data table} - Data with elements/columns \code{SampleID}, \code{ReplicateID}, \code{MP_A} and \code{MP_B}
#' @param silence \code{integer} - Should debugging messages be printed. Default is no
#'
#' @description Structure-requirement of \code{data}:
#' \itemize{
#'   \item{\code{SampleID: }}{Must be a character vector}
#'   \item{\code{ReplicateID: }}{Must be a character vector}
#'   \item{\code{MP_A: }}{Must be a numeric vector}
#'   \item{\code{MP_B: }}{Must be a numeric vector}
#' }
#'
#' @details Calculates various global imprecision estimates. To get CVs in percent you need only to multiply the raw CV estimates with 100. Here is a rough explaination of the output list:
#' \itemize{
#'   \item{\code{Var_A: }}{Pooled variance of all sample-variances based on MS_A}
#'   \item{\code{Var_B: }}{Pooled variance of all sample-variances based on MS_B}
#'   \item{\code{CV_A: }}{Global CV estimate based on Var_A and the grand mean of all measurements from MS_A}
#'   \item{\code{CV_B: }}{Global CV estimate based on Var_B and the grand mean of all measurements from MS_B}
#'   \item{\code{lambda: }}{Ratio of pooled variances Var_A and Var_B}
#' }
#' 
#'
#' @return \code{list} - with point imprecision estimates \code{Var_A}, \code{Var_B}, \code{CV_A}, \code{CV_B} and \code{lambda}
#' @examples \dontrun{
#'   library(fasteqa)
#'   data <- simulate_eqa_data(list(n = 25, R = 3, cvx = 0.02, cvy = 0.3))
#'   data$SampleID <- as.character(data$SampleID)
#'   data$ReplicateID <- as.character(data$ReplicateID)
#'   global_prcision_estimates(data = data)
#' }
NULL

global_precision_estimates <- function(data, silence = 1L) {
    .Call(`_fasteqa_global_precision_estimates`, data, silence)
}

#' Leave-one-out on clustered EQA clinical sample data
#' 
#' @title Leave-one-out on clustered EQA clinical sample data
#' @name leave_one_out
#' 
#' @param data \code{List} or \code{data table} - Data with list elements or data table columns with names \code{SampleID}, \code{ReplicateID}, \code{MP_A} and \code{MP_B}. \code{SampleID} and \code{ReplicateID} must be of character type for the function to operate correctly
#' @param loo_id Integer - Which of the samples of \code{SampleID} should be left out. Default value is 1
#'
#' @description Needed to calculate jack knife estimates of a parameter, that is required when using \code{BCa_bootstrap_ci()}. Alternatively one could use the Jack knife estimates to calculate standard error or bias of the estimator of relevance
#'
#' @details loo_ids can not be vectorized directly in R. Use \code{sapply()} or \code{replicate()} to leave out sample IDs one by one 
#'
#' @return A \code{list} containing the original data, but without the sample id corresponding to the given \code{loo_id} 
#'
#' @examples \dontrun{
#'   library(commutability.selectivity)
#'   data <- sdwdnsp2()
#'   loo_data <- leave_one_out(data, loo_id = 5)
#' }
NULL

leave_one_out <- function(data, loo_id = 1L) {
    .Call(`_fasteqa_leave_one_out`, data, loo_id)
}

#' Merge all commutability evaluation computations efficiently into one object
#' 
#' @title Merge all computations efficiently into one object
#' @name merge_results
#' @param pb_data \code{list} or \code{data table} - Prediction band data, which must at least contain \code{comparison}, \code{predictor}, \code{prediction}, \code{lwr} and \code{upr}
#' @param ce_data \code{list} or \code{data table} - Commutability evaluation data for evaluated material, which must at least contain \code{comparison}, \code{SampleID}, \code{MP_B}, \code{MP_A}, \code{prediction}, \code{lwr}, \code{upr} and \code{inside}
#' @param zeta_data \code{list} or \code{data table} - Zeta estimates, which must at least contain \code{comparison}, \code{zeta}, \code{lwr}, \code{upr}, \code{zeta_critical}, \code{zeta_conclusion}
#' @param imprecision_data \code{list} or \code{data table} - global imprecision estimates, which must at least contain \code{comparison}, \code{CV_A}, \code{CV_A_lwr}, \code{CV_A_upr}, \code{CV_B}, \code{CV_B_lwr}, \code{CV_B_upr}, \code{lambda}, \code{lambda_lwr} and \code{lambda_upr}. This one may be omitted, if one is uninterested in viewing the imprecision estimates
#' @param rounding \code{integer} - How many decimals should be included in the float type variables? The implicit maximum is 6 decimals, meaning that any integer larger than 6 will produce a warning
#' @param include_imprecision_estimates \code{boolean} - Should imprecision estimates be part of the merged results. Default is \code{FALSE}.
#' @param silence \code{integer} - Should progress reports be printed? For yes, pass \code{0}. For no, pass \code{1}. \code{1} is default.
#' 
#' @description Merge all the essential components (e.g., pb_data, ce_data, zeta_data) of the commutability evaluation analysis into one object, so it will be easier to plot and present commutability evaluation results
#' 
#' @details The merging is done with respect to the comparison column that needs to be common in every data input. The effects of missing values in the comparison variable may yield unexpected results or errors, so ensure that at least this column, is NA-free. 
#' 
#' @return A \code{list} with two main components, merged data results for commutability evaluation of control materials and merged results for prediction bands. The latter may be used to plot commutability evaluation plots
#'
#' @examples \dontrun{
#'   library(fasteqa)
#'   data <- simulate_data_eqa(list(n = 25, R = 3, cvx = 0.06, cvy = 0.04))
#'   estimate_zeta(data)
#' }
#'
NULL

merge_results <- function(pb_data, ce_data, zeta_data, imprecision_data, rounding = 3L, include_imprecision_estimates = TRUE, silence = 1L) {
    .Call(`_fasteqa_merge_results`, pb_data, ce_data, zeta_data, imprecision_data, rounding, include_imprecision_estimates, silence)
}

#' Prediction Interval Estimation for EQA Data via Deming or OLS Regression
#'
#' @title Prediction Interval Estimation for EQA Data via Deming or OLS Regression
#' @name predict_eqa
#'
#' @description This function estimates prediction intervals for External Quality Assessment (EQA) data by applying either Deming (\code{method = 'fg'} or \code{method = 'clsi'}) or Ordinary Least Squares (\code{method = 'ols'}) regression methodologies. It is specifically designed for a single In Vitro Diagnostic Medical Device (IVD-MD) comparison. For processing multiple IVD-MD comparisons simultaneously, consider using the \code{estimate_prediction_data()} function from the commutability package, which executes this function on a per IVD-MD comparison basis.   
#'
#' @param data A \code{list} or \code{data.table} representing mean-of-replicates clinical sample data with the \code{list} elements or \code{data.table} columns: \code{SampleID}, \code{MP_A}, and \code{MP_B}.
#' @param new_data A \code{list} or \code{data.table} representing mean-of-replicates EQA material / reference material data. This should at least include \code{MP_B} but may also contain \code{SampleID} and \code{MP_A} depending on the desired output structure:
#' \itemize{
#'   \item{\code{Minimum requirement}: }{new_data must include \code{MP_B}}
#'   \item{\code{method = 'ols'}: }{new_data must include both \code{MP_B} and \code{MP_A}}
#'   \item{\code{Inside checks performed}: }{new_data must include both \code{MP_B} and \code{MP_A}}
#'   \item{\code{Sample-wise prediction}: }{new_data must include \code{MP_B} and \code{SampleID} (plus \code{MP_A} if method = 'ols')}
#' }
#' @param imprecision_estimates A \code{list} or \code{data.table} that includes necessary imprecision estimates. If \code{method} is \code{'fg'} or \code{'ols'}, this parameter should contain \code{lambda}. In case of \code{method = 'clsi'}, both \code{lambda} and \code{Var_B} must be included. The function \code{global_precision_estimates()} can be employed to generate suitable input for this parameter directly.
#' @param R An \code{integer} indicating the number of replicates on which new_data is based. The convenience function \code{count_samplewise_replicates()} can be employed to generate suitable input for this parameter directly
#' @param R_ratio An \code{float} indicating the ratio of replicates between that number data and that number new_data are based on. Only relevant if \code{method = 'fg'} and if the number of replicates of data and new_data differs.
#' @param method A \code{string} specifying the method for estimating the prediction intervals. Default is \code{'fg'}. Current possible prediction interval estimation methods are:
#' \itemize{
#'   \item{\code{fg: }}{Implements standard Deming regression with prediction intervals calculated using the Fuller and Gillard methods.}
#'   \item{\code{clsi: }}{Utilizes standard Deming regression, with prediction intervals derived from the CLSI method.}
#'   \item{\code{ols: }}{Implements Ordinary Least Squares regression, where the predictor is selected to minimize the variance of the ignored IVD-MD uncertainty. Specifically, \code{MP_A} is used as the predictor when \code{lambda < 1}, otherwise, \code{MP_B} is utilized.}
#' }
#' @param level A \code{float} representing the confidence level for the prediction intervals. It should be between \code{0} and \code{1}. The default setting is \code{0.99}. Please adjust for simultaneous testing if pointwise prediction intervals are used for classifying more than one EQA material / reference material in the same IVD-MD comparison.
#' @param rounding An \code{integer} specifying the desired decimal places for the predictions and prediction intervals. The default setting is three, offering sufficient precision. The maximum limit is six due to the utilization of floating-point numbers.
#'
#' @details For optimal results, we recommended to include \code{SampleID}, \code{MP_A}, and \code{MP_B} in new_data whenever possible. If only \code{MP_B} is available, the use of \code{method = 'ols'} is not possible. For instance, when constructing prediction bands, only \code{MP_B} might be available. Thus, \code{method = 'ols'} may sadly not be used to estimate pointwise prediction intervals using this function.
#'
#' @return A \code{list} comprising estimated prediction interval data based on user inputs. The output \code{list} may be converted to \code{data.table} by employing the \code{setDT()} method from the \code{data.table} package in R.
#'
#' @examples \dontrun{
#' library(fasteqa)
#' # Simulation parameters for clinical sample data
#' training_parameters <- list(n = 25, R = 3, cvx = 0.01, cvy = 0.015, cil = 10, ciu = 70)
#' # Simulation parameters for external quality assessment material data (commutable materials)
#' test_parameters <- list(n = 5, R = 3, cvx = 0.01, cvy = 0.015, cil = 10, ciu = 70)
#' # Simulation of clinical sample data using the simulation parameters 'training_parameters'
#' training_data <- simulate_eqa_data(training_parameters)
#' # Simulation of external quality assessment material data based on 'test_parameters'
#' test_data <- simulate_eqa_data(test_parameters)
#' # Convert ID columns to character type because this is the type accepted
#' training_data$SampleID <- as.character(training_data$SampleID)
#' training_data$ReplicateID <- as.character(training_data$ReplicateID)
#' # Estimate imprecision estimates
#' imprecision <- global_precision_estimates(training_data)
#' # Calculate mean-of-replicates data
#' mean_of_replicates_training_data <- fun_of_replicates(training_data)
#' mean_of_replicates_test_data <- fun_of_replicates(test_data)
#' # Estimate prediction intervals using method = 'fg', R = 3L and R_ratio = 1:
#' prediction_intervals <- predict_eqa(mean_of_replicates_training_data,
#'                                     mean_of_replicates_test_data,
#'                                     imprecision)
#' }
NULL

predict_eqa <- function(data, new_data, imprecision_estimates, R = 3L, R_ratio = 1, method = "fg", level = 0.99, rounding = 3L) {
    .Call(`_fasteqa_predict_eqa`, data, new_data, imprecision_estimates, R, R_ratio, method, level, rounding)
}

#' Resample fun-of-replicates data
#' 
#' @title Resample fun-of-replicates data
#' @name resample_fun_data
#' 
#' @param data \code{list} or \code{data table} - Must contain \code{SampleID}, \code{MP_A} and \code{MP_B}. \code{SampleID} and \code{ReplicateID} must be of character type, or else an error is thrown
#' @param make_unique - \code{integer} that controls the output SampleID. If \code{make_unique = 1}, the default, new SampleIDs will be made. Conversely \code{make_unique = 0} will use the original SampleIDs. The latter is not recommended because potential calculations are affected by this 
#'
#' @description In order to construct bootstrap confidence intervals and do inference on a set of population parameters where the underlying distribution is complex, will require bootstrap replicates. This function is both efficient and does its job, but at a cost of a strict input requirement
#'
#' @details Combine with e.g., \code{predict_eqa()}, to estimate classification rates and more
#'
#' @return A list containing the resampled fun-of-replicates data. Use \code{setDT()} for maximum efficiency if you desire to convert the resampled data to a data table
#'
#' @examples \dontrun{
#'   library(fasteqa)
#'   data <- simulate_data_eqa(list(n = 25, R = 3, cvx = 0.06, cvy = 0.04))
#'   data$SampleID <- as.character(data$SampleID)
#'   data$ReplicateID <- as.character(data$ReplicateID)
#'   data <- fun_of_replicates(data, fun = "median")
#'   resampled_data <- resample_fun_data(data)
#' }
NULL

resample_fun_data <- function(data, make_unique = 1L) {
    .Call(`_fasteqa_resample_fun_data`, data, make_unique)
}

#' Resample clustered EQA clinical sample data
#' 
#' @title Resample clustered EQA clinical sample data
#' @name resample_samples
#' 
#' @param data A list or a data table with elements/columns \code{SampleID}, \code{ReplicateID}, \code{MP_A} and \code{MP_B}. \code{SampleID} and \code{ReplicateID} must be of character type for the function to operate correctly
#' @param silence An integer that controls the progress reports outputted for debugging and further examination of the command. \code{silence = -1} or \code{silence = 0} signify that progress reports should be printed. Default is \code{silence = 1} which suppresses all printing
#'
#' @description In order to construct bootstrap confidence intervals and do inference on a set of population parameters where the underlying distribution is complex, will require resample of clustered data. This function is both efficient and does its job, but at a cost of a strict input requirement
#'
#' @details \code{resample_samples()} is a very efficient algorithm to resample EQA. Combine with \code{Estimatek()} to resample k or combine with \code{CharacterEstimatePrecision()} to resample variability measures such as CVs and variances. May also be combined with other functions
#'
#' @return A list containing the resampled EQA clinical sample data. Use \code{setDT()} for maximum efficiency if needed to convert the resampled data to a data table
#'
#' @examples \dontrun{
#'   library(commutability.selectivity)
#'   data <- sdwdnsp2()
#'   data$SampleID <- as.character(data$SampleID)
#'   data$ReplicateID <- as.character(data$ReplicateID)
#'   resampled_data <- resample_samples(data)
#' }
NULL

resample_samples <- function(data, silence = 1L) {
    .Call(`_fasteqa_resample_samples`, data, silence)
}

#' Obtain the residuals based on data and imprecision estimates
#' 
#' @title Obtain the residuals based on data and imprecision estimates
#' @name residuals_eqa
#' 
#' @param data A \code{list} or \code{data.table} that includes mean values of replicated clinical sample data, grouped by \code{SampleID}. The data for the two compared IVD-MDs under consideration should be found in the columns named \code{MP_A} and \code{MP_B}. The \code{SampleID} should be a character vector, whereas \code{MP_A} and \code{MP_B} must be numeric vectors.
#' @param imprecision_estimates A \code{list} or \code{data.table} carrying imprecision estimates for IVD-MD, ideally matching those provided by the \code{global_precision_estimates()} function. A non-missing positive value for \code{lambda} is the minimum requirement.
#' @param method A \code{character} string specifying the linear regression model applied for obtaining the residuals and fitted values. The default value is \code{fg}. The possible values for \code{method} include:
#' \itemize{
#'   \item{\code{fg: }}{Refers to Deming regression, incorporating elements from the work of W. Fuller and J. Gillard.}
#'   \item{\code{clsi: }}{Refers to Deming regression, based on the CLSI EP14 standard.}
#'   \item{\code{ols: }}{Represents ordinary least squares regression.}
#' }
#' @param studentize An \code{integer}. When set to \code{1} (default), the residuals get studentized, implying the mean of the residuals is subtracted from each residual and then divided by the standard deviation of the residuals. If set to \code{0}, residuals are not studentized. Studentized residuals can be beneficial if there is a need to compare the residuals' distribution to the standard normal distribution or a specific t-distribution.
#'
#' @description This function efficiently extracts the residuals and fitted values based on the provided \code{data}, \code{imprecision_estimates}, and \code{method}.
#'
#' @details While the outcome differences between the three provided methods may be minute, they can still be noteworthy. Suppose 'n' is the count of unique clinical samples. The \code{fg} method estimates latent concentration values and utilizes n - 1 degrees of freedom. In contrast, \code{clsi} does not estimate latent variables and uses 'n' degrees of freedom. The model associated with \code{ols} overlooks the imprecision in \code{MP_B}.
#'
#' @return This function returns a \code{list} comprising two numeric vectors named \code{residuals} and \code{fitted}. These are the residuals and fitted values, respectively, based on the input \code{data}, \code{imprecision_estimates}, and \code{method}.
#'
#' @examples \dontrun{
#'   library(fasteqa)
#'   parameters <- list(n = 20, R = 3, cvx = 0.03, cvy = 0.02, cil = 10, ciu = 15)
#'   data <- simulate_eqa_data(training_parameters)
#'   data$SampleID <- as.character(data$SampleID)
#'   data$ReplicateID <- as.character(data$ReplicateID)
#'   imprecision <- global_precision_estimates(data)
#'   mean_of_replicates_data <- fun_of_replicates(data)
#'   # Extracting raw residuals based on the clsi Deming regression approach
#'   residuals_eqa(mean_of_replicates_data, imprecision, "clsi", 0)
#' }
NULL

residuals_eqa <- function(data, imprecision_estimates, method = "fg", studentize = 1L, invalid_NA = FALSE) {
    .Call(`_fasteqa_residuals_eqa`, data, imprecision_estimates, method, studentize, invalid_NA)
}

#' Simulation of EQA data based on study design and potential differences in non-selectivity
#'
#' @title Simulation of EQA data based on study design and potential differences in non-selectivity
#' @name simulate_eqa_data
#' 
#' @param parameters A \code{list} of parameters used to simulate the EQA data. You must at least specify one parameter for this function to run. Except that one mandatory parameter, you may optionally choose the remaining of the parameters. These are the optimal parameters that you may include into the list:
#' \itemize{
#'   \item{\code{n: }}{  The number of clinical samples}
#'   \item{\code{R: }}{The number of replicates on each sample}
#'   \item{\code{cvx: }}{The analytical CV of x measurements}
#'   \item{\code{cvy: }}{The analytical CV of y measurements}
#'   \item{\code{cil: }}{The lower range of the concentration interval}
#'   \item{\code{ciu: }}{The upper range of the concentration interval}
#'   \item{\code{eta: }}{The heteroscedasticity factor}
#'   \item{\code{eta0: }}{The proportion of base MS standard deviations}
#'   \item{\code{qpos: }}{Position of systematic differences in non-selectivity. 0 signify lower range and 1 signify upper range}
#'   \item{\code{qran: }}{Interquantile range where systematic differences in non-selectivity should have its effect}
#'   \item{\code{prop: }}{average proportion of clinical samples affected by random differences in non-selectivity}
#'   \item{\code{mmax: }}{The maximum relocation magnitude in number of analytical SDs of y measurements. This assumes either prop or qpos and qran to be specified as well}
#'   \item{\code{b0: }}{For systematic linear DINS between IVD-MDs. Intercept}
#'   \item{\code{b1: }}{For systematic linear DINS between IVD-MDs. Slope}
#'   \item{\code{c0: }}{For systematic linear non-selectivity in IVD-MD 1. Intercept}
#'   \item{\code{c1: }}{For systematic linear non-selectivity in IVD-MD 1. Slope}
#' }
#' @param silence \code{Integer} should temporary calculation results be printed? This may be useful for debugging or strange curiosity. \code{silence = 1} signify that printing will be suppressed, which is the default. \code{silence = 0} allows such printing 
#' 
#' @description Simulates a data set with n x R rows, and four columns. The two first columns are the base ID columns (\code{SampleID} and \code{ReplicateID}). The remaining columns are numeric columns holding measurement results from the two MSs in comparison (MS_A and MS_B) denoted \code{MP_A} and \code{MP_B}.
#' @details In order to convert the outputted list to a table, use either \code{as.data.frame()}, \code{as.data.table()}, \code{as.tibble()}. The most efficient way to convert is \code{setDT()} from the \code{data.table} package.
#'
#' @return A list where each list element is a column of the generated EQA data
#'
#' @examples \dontrun{
#'   simulated_data <- simulate_eqa_data(parameters = list(n = 25, R = 3, prop = 0.1, mmax = 5))
#'   simulated_data <- setDT(simulated_data)
#' }
#'
NULL

simulate_eqa_data <- function(parameters, silence = 1L) {
    .Call(`_fasteqa_simulate_eqa_data`, parameters, silence)
}

