# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Estimate MS precision measures (variances, CVs and lambda) for character IDs
#' 
#' @title Estimate MS precision measures
#' @name CharacterEstimatePrecision
#' @param data A data frame or table with format LFDT converted to list so that each column is a list element
#' @param silence - Integer, hide helpful (maybe unhelpful for most people) progress reports. Set to 0 for these progress report to appear. For additional debugging information, set this to \code{-1}.
#' 
#' @description Estimate precision of EQA data when the ID columns are of string type. All ID columns must be character vectors for this function to work
#' 
#' @details These estimates are used as part of calculation of relative selectivity, and construction of prediction intervals. They can also be used to visualize the the MS precisions using the much used CVs in percent
#' 
#' @return A list containing estimated MS precision estimates for one group. Can be melted together by using \code{setDT()} from the \code{data.table} package
#' 
#' @examples \dontrun{
#'   print(1)
#' }
#' 
NULL

CharacterEstimatePrecision <- function(data, silence = 1L) {
    .Call(`_fasteqa_CharacterEstimatePrecision`, data, silence)
}

#' Estimate relative non-selectivity measure k based on data
#' 
#' @title Estimate MS precision measures
#' @name Estimatek
#' @param data A data table or a data frame converted to a list so that each column is a unique list element. The ID columns must be of character type and contain SampleID, ReplicateID, MP_A and MP_B 
#' @param silence An integer (-1, 0, 1) that controls how much is printed. 0 shows some messages regarding temporary output, whereas -1 shows even more messages for debugging. -1 is used for superusers.
#' 
#' @description Estimate the relative non-selectivity measure k, that is the ratio of the pooled prediction error variance and the sum of repeatability variances.  
#' 
#' @details Differences in non-selectivity between measurement systems may cause problems in e.g., evaluation of commutability. A large value of k indicate that we have have large differences in selectivity
#' 
#' @return A single estimate of k (in a list) based on the specific grouped data. The k values are float values meaning that the precision is 1e-6 (six decimals precision). This is considered enough for us
#'
#' @examples \dontrun{
#'   print("Estimate k")
#' }
#'
NULL

Estimatek <- function(data, silence = 1L) {
    .Call(`_fasteqa_Estimatek`, data, silence)
}

#' Calculates means of replicate
#' 
#' @title Calculate means of replicates
#' @name MeanOfReplicates
#' 
#' @param data A data frame or data table converted to a list so that every column is unique list elements
#' @param silence should progress reports be outputted? For debugging and additional information, where you set \code{silence} to either -1 or 0. Default is 1, which means that no progress reports should be outputted
#'
#' @description Constructing prediction intervals require EQA data to be on mean-of-replicates-form. So this function should be applied to the EQAM data before it is included into the \code{PredictDeming()} or \code{PredictOLS()}
#'
#' @details The difference between this function and \code{mean_of_replicates()} method in the \code{commutability.selectivity}, is that this is more than ten times faster.
#'
#' @return A list containing the elements that is needed to build the resulting data of results. Use \code{setDT()} for maximum efficiency when converting the list into a data table 
#'
#' @examples \dontrun{
#'   library(commutability.selectivity)
#'   library(data.table)
#'   data <- sampled_cs_measurements
#'   data <- MS_wise(data = data)[Comparison=="MP1 - MP2",]
#'   data$SampleID <- as.character(data$SampleID)
#'   data$ReplicateID <- as.character(data$ReplicateID)
#'   input <- as.list(data)
#'   output <- setDT(MeanOfReplicates(data = input, silence = 1))
#' }
NULL

MeanOfReplicates <- function(data, silence = 1L) {
    .Call(`_fasteqa_MeanOfReplicates`, data, silence)
}

#' Estimate pointwise prediction intervals based on Deming regression
#'
#' @title Estimation of prediction intervals or prediction band based on Deming regression
#' @name PredictDeming
#' 
#' @param data A data table or data frame converted to a list so that each column is a unique list element. Must contain the following columns: MP_A and MP_B
#' @param NewData A numeric vector of which x values are used to predict y
#' @param Precision A list of the Precision estimates based on \code{CharacterEstimatePrecision()}
#' @param MaxR The number of replicates for the majority of clinical samples. For example, if 18 of 25 CSs are meausured in triplicate, and the remaining seven is measured in duplicate, we use \code{MaxR = 3}
#' @param level the confidence level of the pointwise prediction intervals constructed. If the prediction intervals are used to evaluate commutability of EQAMs, you must remember to adjusts for simultanuous testing, e.g., Bonferroni correction
#' @param type which type of estimation approach should be used to construct the pointwise prediction intervals? \code{type = 0} correspond to J. Gillard and W. Fullers' approach. \code{type = 1} corresponds to CLSI's approach (elaborated upon in EP14). The first-mentioned is the default choice
#' @param rounding how many decimal places should be use in the estimates? Default is 3
#' @param Should estimated true concentration levels be part of the output? Default is 0 which signify no. This will only return something if \code{type = 0}
#' @param silence an integer that controls progress reports. Set to 0 for these progress reports to appear. For additional debugging information, set this to \code{-1}. Default is \code{1}, which means that only the output will be returned, and no messages
#' 
#' @description Estimation of prediction intervals based on the Deming model is relevant in e.g., commutability evaluation of EQAMs. 
#' 
#' @return A list with four elements, which are, nx (inputted new data), fit (predicted y values based on new data), lwr (lower prediction interval bound), upr (upper prediction interval bound). Use \code{setDT()} from data.table to merge the list elements into a data table
#'
NULL

PredictDeming <- function(data, NewData, Precision, MaxR, level = 0.99, type = 0L, rounding = 3L, CalculateLatent = 0L, silence = 1L) {
    .Call(`_fasteqa_PredictDeming`, data, NewData, Precision, MaxR, level, type, rounding, CalculateLatent, silence)
}

#' Estimate pointwise prediction intervals based on OLS regression
#'
#' @title Estimation of prediction intervals or prediction band based on OLS regression
#' @name PredictOLS
#' 
#' @param data A data table or data frame converted to a list so that each column is a unique list element. Must contain the following columns: MP_A and MP_B
#' @param NewData A numeric vector of which x values are used to predict y
#' @param Precision A list of the Precision estimates based on \code{CharacterEstimatePrecision()}
#' @param MaxR The number of replicates for the majority of clinical samples. For example, if 18 of 25 CSs are meausured in triplicate, and the remaining seven is measured in duplicate, we use MaxR = 3
#' @param level the confidence level of the pointwise prediction intervals constructed. If the prediction intervals are used to evaluate commutability of EQAMs, you must remember to adjusts for simultanuous testing, e.g., Bonferroni correction
#' @param silence an integer that controls progress reports. Set to 0 for these progress reports to appear. For additional debugging information, set this to \code{-1}. Default is \code{1}, which means that only the output will be returned, and no messages
#' 
#' @description Estimation of prediction intervals based on the OLS regression model is relevant in e.g., commutability evaluation of EQAMs
#' 
#' @return A list with four elements, which are, nx (inputted new data), fit (predicted y values based on new data), lwr (lower prediction interval bound), upr (upper prediction interval bound). Use \code{setDT()} from data.table to merge the list elements into a data table
NULL

PredictOLS <- function(data, NewData, Precision, MaxR, level, silence = 1L) {
    .Call(`_fasteqa_PredictOLS`, data, NewData, Precision, MaxR, level, silence)
}

#' Simulation of EQAM data based on study design, that is, n and R
#'
#' @title Simulate EQAM data for any combination of n and R
#' @name SimulateEqaData
#' 
#' @param n The number of clinical sampels to generate. Must be an integer
#' @param R The number of replicates on each clinical sample. Must be an integer
#' @param silence Should progress reports be outputted. Defaults to no, which is \code{silence = 1}
#' 
#' @description Simulates a data set wit n x R rows, and 4 columns, where the two first is the base ID columns (SampleID and ReplicateID), and the last it the base Measurement columns (MP_A and MP_B). Enjoy
#' @details In order to glue the elements of the output you may use \code{as.data.frame()}, \code{as.data.table()}, \code{as.tibble()}, etc., but the fastest is \code{setDT()} from the \code{data.table} package.
#'
#' @return A list where each list element is a column of the generated data
#'
#' @examples \dontrun{
#'   library(data.table)
#'   n <- 25
#'   R <- 3
#'   simulated_data <- setDT(SimulateEqaData(n = n, R = R))
#' }
#'
NULL

SimulateEqaData <- function(n = 25L, R = 3L, silence = 1L) {
    .Call(`_fasteqa_SimulateEqaData`, n, R, silence)
}

